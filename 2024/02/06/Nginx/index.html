<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Nginx | 知行记</title><meta name="author" content="小辑轻舟"><meta name="copyright" content="小辑轻舟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述Nginx是一个高性能的Http和反向代理服务器及电子邮件代理服务器，可实现高效的反向代理和负载均衡，其特点是占有内存少、并发能力强。 主要特点：  更快：单次请求响应更快，高并发可以更快的处理响应；  高拓展性：设计极具扩展性，由多个不同功能、不同层次、不同类型且耦合度极低的模块组成；  高可靠性：很多高流量网站都在核心服务器上大规模使用Nginx；  低内存消耗：一般1万个非活跃的HTTP">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx">
<meta property="og:url" content="https://liuliangcong.github.io/2024/02/06/Nginx/index.html">
<meta property="og:site_name" content="知行记">
<meta property="og:description" content="概述Nginx是一个高性能的Http和反向代理服务器及电子邮件代理服务器，可实现高效的反向代理和负载均衡，其特点是占有内存少、并发能力强。 主要特点：  更快：单次请求响应更快，高并发可以更快的处理响应；  高拓展性：设计极具扩展性，由多个不同功能、不同层次、不同类型且耦合度极低的模块组成；  高可靠性：很多高流量网站都在核心服务器上大规模使用Nginx；  低内存消耗：一般1万个非活跃的HTTP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liuliangcong.github.io/images/avatar.png">
<meta property="article:published_time" content="2024-02-06T12:51:43.000Z">
<meta property="article:modified_time" content="2024-02-06T13:06:21.878Z">
<meta property="article:author" content="小辑轻舟">
<meta property="article:tag" content="Nginx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liuliangcong.github.io/images/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://liuliangcong.github.io/2024/02/06/Nginx/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Nginx',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-06 21:06:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="知行记"><span class="site-name">知行记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Nginx</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-06T12:51:43.000Z" title="发表于 2024-02-06 20:51:43">2024-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-06T13:06:21.878Z" title="更新于 2024-02-06 21:06:21">2024-02-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Nginx"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Nginx是一个高性能的Http和反向代理服务器及电子邮件代理服务器，可实现高效的反向代理和负载均衡，其特点是占有内存少、并发能力强。</p>
<p>主要特点：</p>
<ul>
<li><p>更快：单次请求响应更快，高并发可以更快的处理响应；</p>
</li>
<li><p>高拓展性：设计极具扩展性，由多个不同功能、不同层次、不同类型且耦合度极低的模块组成；</p>
</li>
<li><p>高可靠性：很多高流量网站都在核心服务器上大规模使用Nginx；</p>
</li>
<li><p>低内存消耗：一般1万个非活跃的HTTP Keep-Alive连接在Nginx中仅消耗2.5MB内存；</p>
</li>
<li><p>高并发：单机支持10万以上的并发连接；</p>
</li>
<li><p>热部署：master管理进程与worker工作进程的分离设计，使得Nginx能够支持热部署。</p>
</li>
</ul>
<p>使用场景：</p>
<ul>
<li>静态资源服务，通过本地文件系统提供服务；</li>
<li>反向代理服务，延伸出包括缓存、负载均衡等；</li>
<li>API服务，OpenResty。</li>
</ul>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p>
<img src="image-20230918171804801.png" alt="image-20230918171804801" style="zoom:80%;" />

<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>正向代理（forward）意思是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
<p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p>
<p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发、负载均衡等。</p>
<p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为它服务。</p>
<p>反向代理的优势：</p>
<ul>
<li>隐藏真实服务器；</li>
<li>负载均衡便于横向扩充后端动态服务；</li>
<li>动静分离，提升系统健壮性。</li>
</ul>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p>
<p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p>
<p>请求爆发式增长的情况下，单台机器性能再强劲也无法满足要求了，这个时候集群的概念产生了。单台服务器解决不了的问题，可以使用多台服务器，然后将请求分发到各服务器上。将负载分发到不同的服务器，这就是负载均衡，核心是分摊压力。Nginx实现负载均衡，一般来说指的是将请求转发给服务器集群。</p>
<p>举个具体的例子：晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员用喇叭喊“请走B口，B口人少车空….”，这个工作人员的作用就是负载均衡。</p>
<img src="image-20230922110138433.png" alt="image-20230922110138433" style="zoom: 80%;" />

<p>Nginx实现负载均衡的策略：</p>
<ul>
<li><p><code>轮询策略</code>：默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</p>
</li>
<li><p><code>最小连接数策略</code>：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，避免向压力大的服务器添加更多的请求。</p>
</li>
<li><p><code>最快响应时间策略</code>：优先分配给响应时间最短的服务器。</p>
</li>
<li><p><code>客户端ip绑定策略</code>：来自同一个ip的请求永远只分配一台服务器，有效解决了动态网页存在的<code>session</code>共享问题。</p>
<blockquote>
<p><code>ip_hash</code>：如果用户已经访问了某台服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。每个请求按访问ip的hash结果分配，这样每个用户固定访问一台后端服务器，以此来解决session共享问题。</p>
</blockquote>
</li>
</ul>
<h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>动静分离是指在web服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提升整个服务的访问性和可维护性。</p>
<img src="image-20230922105147818.png" alt="image-20230922105147818" />

<p>一般来说，都需要将动态资源和静态资源分开，由于Nginx的高并发和静态资源缓存等特性，通常将静态资源部署在Nginx上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p>
<p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在Linux上安装Nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入安装目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local</span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget http://nginx.org/download/nginx-1.15.8.tar.gz </span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf nginx-1.15.8.tar.gz</span><br><span class="line"><span class="comment"># 进入nginx文件夹</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.15.8</span><br><span class="line"><span class="comment"># 安装基础依赖</span></span><br><span class="line">yum -y install gcc pcre-devel zlib-devel openssl-devel</span><br><span class="line"><span class="comment"># 生成makefile文件</span></span><br><span class="line">./configure --with-http_ssl_module</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="comment"># 默认安装在/usr/local/nginx，可以使用命令【whereis nginx】来查看安装目录。</span></span><br><span class="line"><span class="built_in">cd</span> ../nginx</span><br></pre></td></tr></table></figure>

<p>主要关注的文件夹有两个：</p>
<ul>
<li><code>conf</code>文件夹：用于存放配置文件，包含<code>nginx.conf</code>主配置文件。</li>
<li><code>html</code>文件夹：用于存放静态文件。</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>systemctl系统命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开机配置</span></span><br><span class="line">systemctl <span class="built_in">enable</span> nginx <span class="comment"># 开机自动启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> nginx <span class="comment"># 关闭开机自动启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Nginx</span></span><br><span class="line">systemctl start nginx <span class="comment"># 启动Nginx成功后，可以直接访问主机IP，此时会展示Nginx默认页面</span></span><br><span class="line"><span class="comment"># 停止Nginx</span></span><br><span class="line">systemctl stop nginx</span><br><span class="line"><span class="comment"># 重启Nginx</span></span><br><span class="line">systemctl restart nginx</span><br><span class="line"><span class="comment"># 重新加载Nginx</span></span><br><span class="line">systemctl reload nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Nginx 运行状态</span></span><br><span class="line">systemctl status nginx</span><br><span class="line"><span class="comment"># 查看Nginx进程</span></span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"><span class="comment"># 杀死Nginx进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 pid <span class="comment"># 根据上面查看到的Nginx进程号，杀死Nginx进程，-9 表示强制结束进程</span></span><br></pre></td></tr></table></figure>

<p>Nginx应用程序命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/sbin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">./nginx</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">./nginx -s stop </span><br><span class="line"><span class="comment"># 重新加载配置文件，热重启</span></span><br><span class="line">./nginx -s reload</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">./nginx -s reopen</span><br><span class="line"><span class="comment"># 等待工作进程处理完成后关闭</span></span><br><span class="line">./nginx -s quit</span><br><span class="line"><span class="comment"># 查看当前Nginx最终配置</span></span><br><span class="line">./nginx -T</span><br><span class="line"><span class="comment"># 检查配置是否有问题</span></span><br><span class="line">./nginx -t</span><br></pre></td></tr></table></figure>



<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>Nginx启动后访问<code>服务器公网IP</code>，结果如下：</p>
<img src="image-20230912162458898.png" alt="image-20230912162458898" />

<p>注意：如果连接不上，请检查<code>安全组</code>是否开放<code>80</code>端口，或者服务器<code>防火墙</code>是否允许<code>80</code>端口通过。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="comment"># 查看对应端口是否被允许，返回no则表示不允许</span></span><br><span class="line">firewall-cmd --query-port=80/tcp</span><br><span class="line"><span class="comment"># 允许80端口</span></span><br><span class="line">firewall-cmd --permanent --add-port=80/tcp</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>




<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h3><p>Nginx配置文件为<code>conf</code>目录下的<code>nginx.conf</code>，该文件包含Nginx服务器的基础配置。</p>
<p>Nginx的典型配置示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># main段配置信息</span><br><span class="line"># user  nginx;                  # 运行用户，可以不进行设置</span><br><span class="line">worker_processes  auto;         # Nginx进程数，一般设置为和CPU核数一样</span><br><span class="line">error_log  logs/error.log warn; # Nginx的错误日志存放目录</span><br><span class="line">pid        logs/nginx.pid;      # Nginx服务启动时的pid存放位置</span><br><span class="line"></span><br><span class="line"># events段配置信息</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;     			 # 使用epoll的I/O模型（如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的）</span><br><span class="line">    worker_connections 1024; # 每个进程允许最大并发数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># http段配置信息</span><br><span class="line"># 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置</span><br><span class="line">http &#123; </span><br><span class="line">    # 设置日志模式</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main; # Nginx访问日志存放位置</span><br><span class="line"></span><br><span class="line">    sendfile            on; # 开启高效传输模式</span><br><span class="line">    tcp_nopush          on; # 减少网络报文段的数量</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65; # 保持连接的时间，也叫超时时间，单位秒</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             mime.types;				  # 文件扩展名与类型映射表</span><br><span class="line">    default_type        application/octet-stream; # 默认文件类型</span><br><span class="line"></span><br><span class="line">    include conf.d/*.conf; # 加载子配置项</span><br><span class="line">    </span><br><span class="line">    # server段配置信息</span><br><span class="line">    server &#123;</span><br><span class="line">    	listen       80;        # 配置监听的端口</span><br><span class="line">    	server_name  localhost; # 配置的域名</span><br><span class="line">      </span><br><span class="line">    	# location段配置信息</span><br><span class="line">    	location / &#123;</span><br><span class="line">    		root   /usr/local/nginx/html; # 网站根目录</span><br><span class="line">    		index  index.html index.htm;  # 默认首页文件</span><br><span class="line">    		deny 172.168.22.11;  		  # 禁止访问的ip地址，可以为all</span><br><span class="line">    		allow 172.168.33.44; 		  # 允许访问的ip地址，可以为all</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	error_page 500 502 503 504 /50x.html; # 默认50x对应的访问页面</span><br><span class="line">    	error_page 400 404 error.html;   	  # 同上</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>main</code>：全局配置，对全局生效；</li>
<li><code>events</code>：配置影响Nginx服务器与用户的网络连接；</li>
<li><code>http</code>：配置代理、缓存、日志定义等绝大多数功能和第三方模块；</li>
<li><code>server</code>：配置虚拟主机的相关参数，一个<code>http</code>块中可以有多个<code>server</code>块；</li>
<li><code>location</code>：用于配置匹配的<code>uri</code>；</li>
<li><code>upstream</code>：配置后端服务器具体地址，是负载均衡配置不可或缺的部分。</li>
</ul>
<p>层级结构如下图所示：</p>
<img src="image-20230922085402001.png" alt="image-20230922085402001" style="zoom:67%;" />



<h3 id="配置文件main段核心参数"><a href="#配置文件main段核心参数" class="headerlink" title="配置文件main段核心参数"></a>配置文件main段核心参数</h3><p><strong>user</strong></p>
<p>指定运行Nginx的<code>woker</code>子进程的属主和属组，其中组可以不指定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user USERNAME [GROUP]</span><br><span class="line"></span><br><span class="line">user nginx lion; # 用户是nginx，组是lion</span><br></pre></td></tr></table></figure>

<p><strong>pid</strong></p>
<p>指定运行Nginx的<code>master</code>主进程的<code>pid</code>文件存放路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pid /opt/nginx/logs/nginx.pid; # master主进程的的pid存放在nginx.pid文件中</span><br></pre></td></tr></table></figure>

<p><strong>worker_rlimit_nofile_number</strong></p>
<p>指定<code>worker</code>子进程可以打开的最大文件句柄数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_rlimit_nofile 20480; # 可以理解成每个worker子进程的最大连接数量</span><br></pre></td></tr></table></figure>

<p><strong>worker_rlimit_core</strong></p>
<p>指定<code>worker</code>子进程异常终止后的<code>core</code>文件，用于记录分析问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_rlimit_core 50M; # 存放大小限制</span><br><span class="line">working_directory /opt/nginx/tmp; # 存放目录</span><br></pre></td></tr></table></figure>

<p><strong>worker_processes_number</strong></p>
<p>指定Nginx启动的<code>worker</code>子进程数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_processes 4; # 指定具体子进程数量</span><br><span class="line">worker_processes auto; # 与当前cpu物理核心数一致</span><br></pre></td></tr></table></figure>

<p><strong>worker_cpu_affinity</strong></p>
<p>将每个<code>worker</code>子进程与<code>CPU</code>物理核心绑定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_cpu_affinity 0001 0010 0100 1000; # 4个物理核心，4个worker子进程</span><br></pre></td></tr></table></figure>

<img src="image-20240117085324787.png" alt="image-20240117085324787" />

<p>将每个<code>worker</code>子进程与特定<code>CPU</code>物理核心绑定，优势在于避免同一个<code>worker</code>子进程在不同的<code>CPU</code>核心上切换，导致缓存失效，降低性能，但其并不能真正的避免进程切换。</p>
<p><strong>worker_priority</strong></p>
<p>指定<code>worker</code>子进程的<code>nice</code>值，以调整运行Nginx的优先级，通常设定为负值，以优先调用Nginx 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_priority -10; # 120-10=110，110就是最终的优先级</span><br></pre></td></tr></table></figure>

<p>Linux默认进程的优先级值为<code>120</code>，值越小越优先。<code>nice</code>范围为<code>-20</code>到<code>+19</code>。</p>
<blockquote>
<p>注：应用的默认优先级值是<code>120</code>加上<code>nice</code>值等于它最终的值，这个值越小，优先级越高。</p>
</blockquote>
<p><strong>worker_shutdown_timeout</strong></p>
<p>指定<code>worker</code>子进程优雅退出时的超时时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_shutdown_timeout 5s;</span><br></pre></td></tr></table></figure>

<p><strong>timer_resolution</strong></p>
<p><code>worker</code>子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timer_resolution 100ms;</span><br></pre></td></tr></table></figure>

<p>在Linux系统中，用户需要获取计时器时需要向操作系统内核发送请求，有请求就必然会有开销，因此这个间隔越大开销就越小。</p>
<p><strong>daemon</strong></p>
<p>指定Nginx的运行方式，前台还是后台，前台用于调试，后台用于生产。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemon off; # 默认是on，后台运行模式</span><br></pre></td></tr></table></figure>



<h3 id="配置文件events段核心参数"><a href="#配置文件events段核心参数" class="headerlink" title="配置文件events段核心参数"></a>配置文件events段核心参数</h3><p><strong>use</strong></p>
<p>Nginx使用何种事件驱动模型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use method; # 不推荐配置它，让nginx自己选择</span><br><span class="line"></span><br><span class="line">method可选值为：select、poll、kqueue、epoll、/dev/poll、eventport</span><br></pre></td></tr></table></figure>

<p><strong>worker_connections</strong></p>
<p><code>worker</code>子进程能够处理的最大并发连接数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_connections 1024; # 每个子进程的最大连接数为1024</span><br></pre></td></tr></table></figure>

<p><strong>accept_mutex</strong></p>
<p>是否打开负载均衡互斥锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accept_mutex on; # 默认是off关闭的，这里推荐打开</span><br></pre></td></tr></table></figure>



<h3 id="server-name指令"><a href="#server-name指令" class="headerlink" title="server_name指令"></a>server_name指令</h3><p>指定虚拟主机域名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_name name1 name2 name3</span><br><span class="line"></span><br><span class="line"># 示例：</span><br><span class="line">server_name www.nginx.com;</span><br></pre></td></tr></table></figure>

<p>域名匹配的四种写法：</p>
<ul>
<li><p>精确匹配：<code>server_name www.nginx.com</code>;</p>
</li>
<li><p>左侧通配：<code>server_name *.nginx.com</code>;</p>
</li>
<li><p>右侧通配：<code>server_name www.nginx.*</code>;</p>
</li>
<li><p>正则匹配：<code>server_name ~^www\.nginx\.*$</code>。</p>
</li>
</ul>
<p>匹配优先级：精确匹配 &gt; 左侧通配符匹配 &gt; 右侧通配符匹配 &gt; 正则表达式匹配。</p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>指定静态资源目录位置，它可以写在<code>http</code>、<code>server</code>、<code>location</code>等配置中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root path</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location /image &#123;</span><br><span class="line">	root /opt/nginx/static;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<code>root</code>会将定义路径与<code>URI</code>叠加，而<code>alias</code>只取定义路径。</p>
</blockquote>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>它也是指定静态资源目录位置，但只能写在<code>location</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /image &#123;</span><br><span class="line">	alias /opt/nginx/static/image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：使用<code>alias</code>时末尾是否需要添加<code>/</code>取决于<code>location</code>中的<code>URI</code>末尾是否有<code>/</code>，若<code>URI</code>末尾存在<code>/</code>，则<code>alias</code>末尾需要添加<code>/</code>，否则可省略。</p>
</blockquote>
<h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>配置路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~ ] uri &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配规则：</p>
<ul>
<li><code>=</code>：精确匹配；</li>
<li><code>~</code>：正则匹配，区分大小写；</li>
<li><code>~*</code>：正则匹配，不区分大小写；</li>
<li><code>^~</code>：匹配到即停止搜索。</li>
</ul>
<p>匹配优先级：<code>=</code> &gt; <code>^~</code> &gt; <code>~</code> &gt; <code>~*</code> &gt; 不带任何字符。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name	www.nginx-test.com;</span><br><span class="line"></span><br><span class="line">    # 只有当访问 www.nginx-test.com/match_all/ 时才会匹配到 /usr/local/nginx/html/match_all/index.html</span><br><span class="line">    location = /match_all/ &#123;</span><br><span class="line">        root /usr/local/nginx/html;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 当访问 www.nginx-test.com/1.jpg 时会去 /usr/local/nginx/images/1.jpg 中找对应的资源</span><br><span class="line">    location ~ \.(jpeg|jpg|png|svg)$ &#123;</span><br><span class="line">    	root /usr/local/nginx/images;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 当访问 www.nginx-test.com/bbs/ 时会匹配上 /usr/local/nginx/html/bbs/index.html</span><br><span class="line">    location ^~ /bbs/ &#123;</span><br><span class="line">        root /usr/local/nginx/html;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>location URI结尾带不带&#x2F;</strong></p>
<p>如果<code>URL</code>的结构为<code>http://www.nginx-test.com/homepage/</code>。尾部如果缺少<code>/</code>将导致重定向，因为根据约定，<code>URL</code>尾部的<code>/</code>表示目录，没有<code>/</code>表示文件。所以访问<code>/homepage/</code>时，服务器会自动去该目录下找对应的默认文件。如果访问<code>/homepage</code>的话，服务器会先去找<code>homepage</code>文件，找不到的话会将<code>homepage</code>当成目录，重定向到<code>/homepage/</code>，去该目录下找默认文件。</p>
<blockquote>
<p><strong>URI</strong></p>
<p>URI，统一资源标志符（Uniform Resource Identifier），表示的是<code>Web</code>上每一种可用的资源，如<code>HTML</code>文档、图像、视频片段、程序等都由一个URI进行标识的。</p>
<p>URI通常由三部分组成：</p>
<ul>
<li>资源的命名机制</li>
<li>存放资源的主机名</li>
<li>资源自身的名称</li>
</ul>
<blockquote>
<p>注意：这只是一般URI资源的命名方式，只要是可以唯一标识资源的都被称为URI，上面三条合在一起是URI的充分不必要条件。</p>
</blockquote>
<p>URI举例：<code>https://www.nginx-test.com/img/1.jpg</code></p>
<p>解释：</p>
<ol>
<li>这是一个可以通过<code>https</code>协议访问的资源；</li>
<li>位于主机<code>www.nginx-test.com</code>上；</li>
<li>通过<code>/img/1.jpg</code>可以对该资源进行唯一标识（注意，这个不一定是完整的路径）。</li>
</ol>
<blockquote>
<p>注意：以上三点只不过是对实例的解释，以上三点并不是URI的必要条件，URI只是一种概念，怎样实现无所谓，只要它唯一标识一个资源就可以了。</p>
</blockquote>
<p><strong>URL</strong></p>
<p>URL，统一资源定位符（Uniform Resource Locator）。通俗地说，URL是<code>Internet</code>上描述信息资源的字符串，主要用在各种<code>www</code>客户程序和服务器程序上。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式。</p>
<p>URL的一般格式为（带方括号<code>[]</code>的为可选项）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme://host[:port#]/path/.../[;url-params][?query-string][#anchor]</span><br><span class="line"></span><br><span class="line">scheme       # 有我们很熟悉的http、https、ftp以及著名的ed2k、迅雷的thunder等</span><br><span class="line">host         # HTTP服务器的IP地址或者域名</span><br><span class="line">port#        # HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如tomcat的默认端口是8080 -&gt; http://localhost:8080/</span><br><span class="line">path         # 访问资源的路径</span><br><span class="line">url-params   # 所带参数 </span><br><span class="line">query-string # 发送给http服务器的数据</span><br><span class="line">anchor       # 锚点定位</span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<p>从上面的例子来看，可能觉得URI和URL是相同的概念，其实并不是，URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。</p>
</blockquote>
<p><strong>return</strong></p>
<p>停止处理请求，直接返回响应码或重定向到其他<code>URL</code>。执行<code>return</code>指令后，<code>location</code>中后续指令将不会被执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return code [text];</span><br><span class="line">return code URL;</span><br><span class="line">return URL;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location / &#123;</span><br><span class="line">	return 404; # 直接返回状态码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">	return 404 &quot;pages not found&quot;; # 返回状态码 + 一段文本</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">	return 302 /bbs ; # 返回状态码 + 重定向地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">	return https://www.baidu.com ; # 返回重定向地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h3><p>根据指定正则表达式匹配规则，重写<code>URL</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：rewrite 正则表达式 要替换的内容 [flag];</span><br><span class="line"></span><br><span class="line">上下文：server、location、if</span><br><span class="line"></span><br><span class="line">示例：rewrite /images/(.*\.jpg)$ /pic/$1; # $1是前面括号(.*\.jpg)的反向引用</span><br></pre></td></tr></table></figure>

<p><code>flag</code>可选值的含义：</p>
<ul>
<li><p><code>last</code>：重写后的<code>URL</code>发起新请求，再次进入<code>server</code>段，重试<code>location</code>中的匹配；</p>
</li>
<li><p><code>break</code>：直接使用重写后的<code>URL</code>，不再匹配其它<code>location</code>中语句；</p>
</li>
<li><p><code>redirect</code>：返回<code>302</code>临时重定向；</p>
</li>
<li><p><code>permanent</code>：返回<code>301</code>永久重定向。</p>
</li>
</ul>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name nginx-test.com; # 要在本地hosts文件进行配置</span><br><span class="line">    root html;</span><br><span class="line">    location /search &#123;</span><br><span class="line">    	rewrite ^/(.*) https://www.baidu.com redirect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /images &#123;</span><br><span class="line">    	rewrite /images/(.*) /pics/$1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /pics &#123;</span><br><span class="line">    	rewrite /pics/(.*) /photos/$1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /photos &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>按照这个配置进行分析：</p>
<ul>
<li>当访问<code>nginx-test.com/search</code>时，会自动帮我们重定向到<code>https://www.baidu.com</code>。</li>
<li>当访问<code>nginx-test.com/images/1.jpg</code>时，第一步重写<code>URL</code>为<code>nginx-test.com/pics/1.jpg</code>，找到<code>pics</code>的<code>location</code>，继续重写<code>URL</code>为<code>nginx-test.com/photos/1.jpg</code>，找到<code>/photos</code>的<code>location</code>后，去<code>html/photos</code>目录下寻找<code>1.jpg</code>静态资源。</li>
</ul>
<h3 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：if (condition) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">上下文：server、location</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">if ($http_user_agent ~ Chrome) &#123;</span><br><span class="line">	rewrite /(.*)/browser/$1 break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>condition</code>判断条件：</p>
<ul>
<li><code>$variable</code>：仅为变量时，值为空或以0开头字符串都会被当做<code>false</code>处理；</li>
<li><code>=</code>或<code>!=</code>：相等或不等；</li>
<li><code>~</code>：正则匹配；</li>
<li><code>! ~</code>：非正则匹配；</li>
<li><code>~*</code>：正则匹配，不区分大小写；</li>
<li><code>-f</code>或<code>! -f</code>：检测文件存在或不存在；</li>
<li><code>-d</code>或<code>! -d</code>：检测目录存在或不存在；</li>
<li><code>-e</code>或<code>! -e</code>：检测文件、目录、符号链接等存在或不存在；</li>
<li><code>-x</code>或<code>! -x</code>：检测文件可以执行或不可执行。</li>
</ul>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    root html;</span><br><span class="line">    location / &#123;</span><br><span class="line">        if ( $uri = &quot;/images/&quot; )&#123;</span><br><span class="line">        	rewrite (.*) /pics/ break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：当访问<code>localhost:8080/images/</code>时，会进入<code>if</code>判断里面执行<code>rewrite</code>命令。</p>
<h3 id="autoindex"><a href="#autoindex" class="headerlink" title="autoindex"></a>autoindex</h3><p>用户请求以<code>/</code>结尾时，列出目录结构，可以用于快速搭建静态资源下载网站。</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name nginx-test.com;</span><br><span class="line"></span><br><span class="line">    location /download/ &#123;</span><br><span class="line">        root /opt/source;</span><br><span class="line"></span><br><span class="line">        autoindex on; # 打开autoindex，可选参数有 on | off</span><br><span class="line">        autoindex_exact_size on; # 修改为off，以KB、MB、GB显示文件大小，默认为on，以bytes显示出⽂件的确切⼤⼩</span><br><span class="line">        autoindex_format html; # 以html的方式进行格式化，可选参数有 html | json | xml</span><br><span class="line">        autoindex_localtime off; # 显示的⽂件时间为⽂件的服务器时间，默认为off，显示的⽂件时间为GMT时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：当访问<code>nginx-test.com/download/</code>时，会把服务器<code>/opt/source/download/</code>路径下的文件展示出来。</p>
<h2 id="实战配置"><a href="#实战配置" class="headerlink" title="实战配置"></a>实战配置</h2><p>在配置反向代理和负载均衡等功能之前，有两个核心模块是必须掌握的，这两个模块可以说是Nginx应用配置中的核心，它们分别是：<code>upstream</code>、<code>proxy_pass</code>。</p>
<h3 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h3><p>用于定义上游服务器（指的是后台提供的应用服务器）的相关信息。</p>
<img src="image-20240117114123786.png" alt="image-20240117114123786" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：upstream name &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">upstream back_end_server &#123;</span><br><span class="line">  	server 192.168.100.33:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>upstream</code>内可使用的指令：</p>
<ul>
<li><code>server</code>：定义上游服务器地址；</li>
<li><code>zone</code>：定义共享内存，用于跨<code>worker</code>子进程；</li>
<li><code>keepalive</code>：对上游服务启用长连接；</li>
<li><code>keepalive_requests</code>：一个长连接最多请求<code>HTTP</code>的个数；</li>
<li><code>keepalive_timeout</code>：空闲情形下，一个长连接的超时时长；</li>
<li><code>hash</code>：哈希负载均衡算法；</li>
<li><code>ip_hash</code>：依据<code>IP</code>进行哈希计算的负载均衡算法；</li>
<li><code>least_conn</code>：最少连接数负载均衡算法；</li>
<li><code>least_time</code>：最短响应时间负载均衡算法；</li>
<li><code>random</code>：随机负载均衡算法。</li>
</ul>
<p><strong>server</strong></p>
<p>定义上游服务器地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：server address [parameters]</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>

<p><code>parameters</code>可选值：</p>
<ul>
<li><code>weight=number</code>：权重值，默认为1；</li>
<li><code>max_conns=number</code>：上游服务器的最大并发连接数；</li>
<li><code>fail_timeout=time</code>：服务器不可用的判定时间；</li>
<li><code>max_fails=numer</code>：服务器不可用的检查次数；</li>
<li><code>backup</code>：备份服务器，仅当其他服务器都不可用时才会启用；</li>
<li><code>down</code>：标记服务器长期不可用，离线维护。</li>
</ul>
<p><strong>keepalive</strong></p>
<p>限制每个<code>worker</code>子进程与上游服务器空闲长连接的最大数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keepalive connections;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br><span class="line"></span><br><span class="line">示例：keepalive 16;</span><br></pre></td></tr></table></figure>

<p><strong>keepalive_requests</strong></p>
<p>单个长连接可以处理的最多<code>HTTP</code>请求个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：keepalive_requests number;</span><br><span class="line"></span><br><span class="line">默认值：keepalive_requests 100;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>

<p><strong>keepalive_timeout</strong></p>
<p>空闲长连接的最长保持时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：keepalive_timeout time;</span><br><span class="line"></span><br><span class="line">默认值：keepalive_timeout 60s;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>

<p><strong>配置实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream back_end &#123;</span><br><span class="line">    server 127.0.0.1:8081 weight=3 max_conns=1000 fail_timeout=10s max_fails=2;</span><br><span class="line">    keepalive 32;</span><br><span class="line">    keepalive_requests 50;</span><br><span class="line">    keepalive_timeout 30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h3><p>用于配置代理服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_pass URL;</span><br><span class="line"></span><br><span class="line">上下文：location、if、limit_except</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">proxy_pass http://127.0.0.1:8081;</span><br><span class="line">proxy_pass http://127.0.0.1:8081/proxy;</span><br></pre></td></tr></table></figure>

<p><code>URL</code>参数原则：</p>
<ol>
<li><code>URL</code>必须以<code>http</code>或<code>https</code>开头；</li>
<li><code>URL</code>中可以携带变量；</li>
<li><code>URL</code>中是否带<code>URI</code>，会直接影响发往上游请求的<code>URL</code>。</li>
</ol>
<p>接下来让我们来看看两种常见的URL用法：</p>
<ul>
<li><code>proxy_pass http://192.168.100.33:8081</code> </li>
<li><code>proxy_pass http://192.168.100.33:8081/</code></li>
</ul>
<p>这两种用法的区别就是<code>带/</code>和<code>不带/</code>，在配置代理时区别如下：</p>
<ul>
<li><code>不带/</code>意味着Nginx不会修改用户<code>URL</code>，而是直接传给上游的应用服务器；</li>
<li><code>带/</code>意味着Nginx会修改用户<code>URL</code>，修改方法是将<code>location</code>后的<code>URI</code>从用户<code>URL</code>中删除。</li>
</ul>
<p><strong>不带&#x2F;的用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /bbs/ &#123;</span><br><span class="line">	proxy_pass http://127.0.0.1:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li>用户请求<code>URL</code>：<code>/bbs/abc/test.html</code> </li>
<li>请求到达Nginx的<code>URL</code>：<code>/bbs/abc/test.html</code> </li>
<li>请求到达上游应用服务器的<code>URL</code>： <code>/bbs/abc/test.html</code></li>
</ol>
<p><strong>带&#x2F;的用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /bbs/&#123;</span><br><span class="line">	proxy_pass http://127.0.0.1:8080/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li><p>用户请求<code>URL</code>：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达Nginx的<code>URL</code>：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达上游应用服务器的<code>URL</code>：<code>abc/test.html</code></p>
</li>
</ol>
<p>并没有拼接上<code>/bbs/</code>，这点和<code>root</code>与<code>alias</code>之间的区别是保持一致的。</p>
<h3 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h3><p>典型场景：反向代理（Reverse Proxy）方式是指以代理服务器来接受<code>internet</code>上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给<code>internet</code>上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<img src="image-20240117173335047.png" alt="image-20240117173335047" style="zoom:80%;" />

<p>Nginx主要作为应用接入层，并为后端的<code>tomcat</code>等服务实现反向代理。</p>
<h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><ol>
<li><p>在<code>/usr/local/nginx/conf/</code>下创建<code>conf.d</code>目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/conf/</span><br><span class="line"><span class="built_in">mkdir</span> conf.d</span><br></pre></td></tr></table></figure>

<p>修改Nginx默认配置<code>nginx.conf</code>，新增内容如下：</p>
<img src="image-20240119090202382.png" alt="image-20240119090202382" />

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增内容</span></span><br><span class="line">include conf.d/*.conf;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>conf.d</code>目录创建<code>reverse_proxy.conf</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> conf.d</span><br><span class="line">vim reverse_proxy.conf</span><br></pre></td></tr></table></figure>

<p>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80; </span><br><span class="line">    server_name reverse_proxy.com; </span><br><span class="line">    location / &#123; </span><br><span class="line">        proxy_pass https://www.baidu.com; </span><br><span class="line">        proxy_set_header Host $proxy_host; </span><br><span class="line">        #proxy_set_header Host $host; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新加载Nginx配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问<code>服务器公网IP</code>，此时直接跳转到百度页面。</p>
</li>
</ol>
<h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><p>准备两台服务器，公网<code>IP</code>分别是<code>1.12.36.60</code>、<code>121.43.178.226</code></p>
<p><strong>把1.12.36.60服务器作为上游服务器</strong></p>
<ol>
<li><p>在<code>/usr/local/nginx/conf/</code>下创建<code>conf.d</code>目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/conf/</span><br><span class="line"><span class="built_in">mkdir</span> conf.d</span><br></pre></td></tr></table></figure>

<p>修改Nginx默认配置<code>nginx.conf</code>，新增内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增内容</span></span><br><span class="line">include conf.d/*.conf;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>conf.d</code>目录创建<code>proxy.conf</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> conf.d</span><br><span class="line">vim proxy.conf</span><br></pre></td></tr></table></figure>

<p>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name proxy.com;</span><br><span class="line">    location /proxy/ &#123;</span><br><span class="line">        root html/proxy;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>/usr/local/nginx/html/</code>下创建<code>proxy</code>目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/html/</span><br><span class="line"><span class="built_in">mkdir</span> proxy</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>proxy</code>目录创建<code>index.html</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> proxy</span><br><span class="line">vim index.html</span><br></pre></td></tr></table></figure>

<p>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt; 1.12.36.60 proxy html &lt;/h1&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置完成后重启<code>Nginx</code>服务器。</p>
</li>
<li><p>访问<code>http://1.12.36.60/proxy/</code>，结果如下：</p>
<img src="image-20240122084922862.png" alt="image-20240122084922862" /></li>
</ol>
<p><strong>把121.43.178.226服务器作为代理服务器</strong></p>
<ol>
<li><p>在<code>/usr/local/nginx/conf/</code>下创建<code>conf.d</code>目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/conf/</span><br><span class="line"><span class="built_in">mkdir</span> conf.d</span><br></pre></td></tr></table></figure>

<p>修改Nginx默认配置<code>nginx.conf</code>，新增内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增内容</span></span><br><span class="line">include conf.d/*.conf;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>conf.d</code>目录创建<code>proxy.conf</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> conf.d</span><br><span class="line">vim proxy.conf</span><br></pre></td></tr></table></figure>

<p>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream back_end &#123;</span><br><span class="line">    server 1.12.36.60 weight=2 max_conns=1000 fail_timeout=10s max_fails=3;</span><br><span class="line">    keepalive 32;</span><br><span class="line">    keepalive_requests 80;</span><br><span class="line">    keepalive_timeout 20s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name proxy.com;</span><br><span class="line">    location /proxy &#123;</span><br><span class="line">    	proxy_pass http://back_end/proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置完成后重启<code>Nginx</code>服务器。</p>
</li>
<li><p>访问<code>http://121.43.178.226/proxy/</code>，结果如下：</p>
<img src="image-20240118112037030.png" alt="image-20240118112037030" /></li>
</ol>
<p><strong>分析</strong></p>
<ul>
<li><p>当访问<code>http://121.43.178.226/proxy/</code>时通过<code>upstream</code>的配置找到<code>1.12.36.60</code>；</p>
</li>
<li><p>因此访问地址变为<code>http://1.12.36.60/proxy/</code>；</p>
</li>
<li><p>连接到<code>1.12.36.60</code>服务器，找到提供的<code>server</code>；</p>
</li>
<li><p>通过<code>server</code>找到<code>html/proxy/index.html</code>资源，最终展示出来。</p>
</li>
</ul>
<h3 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h3><p>作用：Nginx会按照相应的策略将客户端发来的请求转发至不同的应用服务器上，减轻单台服务器的压力，提高服务器的并发量。</p>
<p>Nginx负载均衡策略有6种：</p>
<ol>
<li><p>轮询：默认策略，Nginx自带策略，它是<code>upstream</code>模块默认的负载均衡默认策略，会将每个请求按时间顺序分配到不同的后端服务器。</p>
</li>
<li><p><code>weight</code>：权重，Nginx自带策略，指定轮询的访问几率，用于后端服务器性能不均时调整访问比例。</p>
</li>
<li><p><code>ip_hash</code>：依据<code>IP</code>分配，Nginx自带策略，指定负载均衡器按照基于客户端<code>IP</code>的分配方式，这个方法确保了相同客户端的请求一直发送到相同的服务器，可以解决<code>session</code>不能跨服务器的问题。</p>
</li>
<li><p><code>least_conn</code>：最少连接，Nginx自带策略，把请求转发给连接数较少的后端服务器。</p>
</li>
<li><p><code>fair</code>：第三方，按照服务器端的响应时间来分配请求，响应时间短的优先分配。</p>
</li>
<li><p><code>url_hash</code>：第三方，该策略按访问<code>URL</code>的<code>hash</code>结果来分配请求，使每个<code>URL</code>定向到同一台后端服务器，需要配合缓存用。</p>
</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>把<code>1.12.36.60</code>服务器作为上游服务器，做如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /usr/loca/nginx/conf/conf.d/balance.conf</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    listen 8020;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	return 200 &#x27;return 8020 \n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    listen 8030;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	return 200 &#x27;return 8030 \n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    listen 8040;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	return 200 &#x27;return 8040 \n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后重启Nginx服务器。</p>
<p>把<code>121.43.178.226</code>服务器作为代理服务器，做如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /usr/local/nginx/conf/conf.d/balance.conf</span><br><span class="line"></span><br><span class="line">upstream demo_server &#123;</span><br><span class="line">    server 1.12.36.60:8020;</span><br><span class="line">    server 1.12.36.60:8030;</span><br><span class="line">    server 1.12.36.60:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name balance.com;</span><br><span class="line">    location /balance/ &#123;</span><br><span class="line">    	proxy_pass http://demo_server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后重启Nginx服务器。</p>
<p>执行<code>curl http://121.43.178.226/balance/</code>命令，结果如下：</p>
<img src="image-20240118130036649.png" alt="image-20240118130036649" />

<p>可以看出负载均衡的配置已经生效了，每次给我们分发的上游服务器都不一样。这时只是通过简单的轮询策略进行上游服务器分发，接下来再来了解下Nginx的其它分发策略。</p>
<h4 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h4><p>通过制定关键字作为<code>hash key</code>，基于<code>hash</code>算法映射到特定的上游服务器中。关键字可以包含有变量、字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    server 121.42.11.34:8020;</span><br><span class="line">    server 121.42.11.34:8030;</span><br><span class="line">    server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name balance.com;</span><br><span class="line"></span><br><span class="line">    location /balance/ &#123;</span><br><span class="line">	    proxy_pass http://demo_server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hash $request_uri</code>表示使用<code>request_uri</code>变量作为<code>hash</code>的<code>key</code>值，只要访问的<code>uri</code>保持不变，就会一直分发给同一台服务器。</p>
<img src="image-20240118130531619.png" alt="image-20240118130531619" />



<h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p>根据客户端的请求<code>IP</code>进行判断，只要<code>IP</code>地址不变，就永远分配到同一台主机，它可以有效解决后台服务器<code>session</code>保持的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 121.42.11.34:8020;</span><br><span class="line">    server 121.42.11.34:8030;</span><br><span class="line">    server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name balance.com;</span><br><span class="line"></span><br><span class="line">    location /balance/ &#123;</span><br><span class="line">    	proxy_pass http://demo_server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="image-20240118130743765.png" alt="image-20240118130743765" />



<h4 id="最小连接数算法"><a href="#最小连接数算法" class="headerlink" title="最小连接数算法"></a>最小连接数算法</h4><p>各个<code>worker</code>子进程通过读取共享内存的数据，来获取后端服务器的信息，挑选一台当前已建立连接数最少的服务器进行分配请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：least_conn;</span><br><span class="line"></span><br><span class="line">上下文：upstream;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">    zone test 10M; # zone可以设置共享内存空间的名字和大小</span><br><span class="line">    least_conn;</span><br><span class="line">    server 121.42.11.34:8020;</span><br><span class="line">    server 121.42.11.34:8030;</span><br><span class="line">    server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name balance.com;</span><br><span class="line"></span><br><span class="line">    location /balance/ &#123;</span><br><span class="line">    	proxy_pass http://demo_server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="image-20240118131131406.png" alt="image-20240118131131406" />



<h4 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">    server 1.12.36.60:8020 weight=6;</span><br><span class="line">    server 1.12.36.60:8030 weight=6;</span><br><span class="line">    server 1.12.36.60:8040 weight=2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name balance.com;</span><br><span class="line"></span><br><span class="line">    location /balance/ &#123;</span><br><span class="line">    	proxy_pass http://demo_server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="image-20240118143902512.png" alt="image-20240118143902512" />



<h4 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h4><p>在一般情况下，升级服务器端应用，需要将应用源码或程序包上传到服务器，然后停止掉老版本服务，再启动新版本。但是这种简单的发布方式存在两个问题，一方面，在新版本升级过程中，服务是暂时中断的，另一方面，如果新版本有BUG，升级失败，回滚起来也非常麻烦，容易造成更长时间的服务不可用。下面介绍一种解决策略——<code>灰度发布</code>。</p>
<p>灰度发布也叫金丝雀发布，起源是，矿井工人发现，金丝雀对瓦斯气体很敏感，矿工会在下井之前，先放一只金丝雀到井中，如果金丝雀不叫了，就代表瓦斯浓度高。</p>
<img src="image-20240118153035212.png" alt="image-20240118153035212" style="zoom:80%;" />

<p>在灰度发布开始后，先启动一个新版本应用，但是并不直接将流量切过来，而是测试人员对新版本进行线上测试，启动的这个新版本应用，就是我们的金丝雀。如果没有问题，那么可以将少量的用户流量导入到新版本上，然后再对新版本做运行状态观察，收集各种运行时数据，如果此时对新旧版本做各种数据对比，就是所谓的<code>A/B测试</code>。</p>
<p>当确认新版本运行良好后，再逐步将更多的流量导入到新版本上，在此期间，还可以不断地调整新旧两个版本的运行服务器副本数量，以使得新版本能够承受越来越大的流量压力，直到将100%的流量都切换到新版本上，最后关闭剩下的老版本服务，完成灰度发布。</p>
<p>如果在灰度发布过程中（灰度期）发现了新版本有问题，就应该立即将流量切回老版本上，这样可以将负面影响控制在最小范围内。</p>
<p>使用场景：利用灰度发布稳定低风险地实现迁移后业务验证以及业务割接。</p>
<img src="image-20240118150520681.png" alt="image-20240118150520681" style="zoom:80%;" />



<h3 id="配置缓存"><a href="#配置缓存" class="headerlink" title="配置缓存"></a>配置缓存</h3><p>缓存可以非常有效的提升性能，因此不论是客户端（浏览器），还是代理服务器（Nginx），乃至上游服务器都多少会涉及到缓存。</p>
<p><strong>proxy_cache</strong></p>
<p>存储一些之前被访问过、而且可能将要被再次访问的资源，使用户可以直接从代理服务器获得，从而减少上游服务器的压力，加快整体访问速度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_cache zone | off ; # zone 是共享内存的名称</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache off;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br></pre></td></tr></table></figure>

<p><strong>proxy_cache_path</strong></p>
<p>设置缓存文件的存放路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_cache_path path [level=levels] ... # 可选参数省略，下面会详细列举</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache_path off;</span><br><span class="line"></span><br><span class="line">上下文：http</span><br></pre></td></tr></table></figure>

<p>参数含义：</p>
<ul>
<li><code>path</code>：缓存文件的存放路径。</li>
<li><code>level</code>：<code>path</code>的目录层级。</li>
<li><code>keys_zone</code>：设置共享内存。</li>
<li><code>inactive</code>：在指定时间内没有被访问，缓存会被清理，默认10分钟。</li>
</ul>
<p><strong>proxy_cache_key</strong></p>
<p>设置缓存文件的<code>key</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_cache_key</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache_key $scheme$proxy_host$request_uri;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br></pre></td></tr></table></figure>

<p><strong>proxy_cache_valid</strong></p>
<p>配置什么状态码可以被缓存，以及缓存时长。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_cache_valid [code...] time;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">配置示例：proxy_cache_valid 200 304 2m; # 对于状态为200和304的缓存文件，缓存时间为2分钟</span><br></pre></td></tr></table></figure>

<p><strong>proxy_no_cache</strong></p>
<p>定义条件，如果至少一个字符串条件非空而且非0，则该响应不会被缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_no_cache string;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">示例：proxy_no_cache $http_pragma $http_authorization;</span><br></pre></td></tr></table></figure>

<p><strong>proxy_cache_bypass</strong></p>
<p>定义条件，如果至少一个字符串条件非空而且非0，Nginx就不会从缓存中获取响应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_cache_bypass string;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">示例：proxy_cache_bypass $http_pragma $http_authorization;</span><br></pre></td></tr></table></figure>

<p><strong>upstream_cache_status</strong></p>
<p>它存储了缓存是否命中的信息，会设置在响应头信息中，在调试中非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MISS: 未命中缓存</span><br><span class="line">HIT： 命中缓存</span><br><span class="line">EXPIRED: 缓存过期</span><br><span class="line">STALE: 命中了陈旧缓存</span><br><span class="line">REVALIDDATED: Nginx验证陈旧缓存依然有效</span><br><span class="line">UPDATING: 内容陈旧，但正在更新</span><br><span class="line">BYPASS: X响应从原始服务器获取</span><br></pre></td></tr></table></figure>

<p><strong>配置实例</strong></p>
<p>把<code>1.12.36.60</code>服务器作为上游服务器，做如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /usr/local/nginx/conf/conf.d/cache.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8020;</span><br><span class="line">    location / &#123;</span><br><span class="line">	    root html/8020;</span><br><span class="line">    	index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8030;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root html/8030;</span><br><span class="line">    	index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># html/8020/index.html</span><br><span class="line">&lt;h1&gt; 1.12.36.60 - 8020 html &lt;/h1&gt;</span><br><span class="line"></span><br><span class="line"># html/8030/index.html</span><br><span class="line">&lt;h1&gt; 1.12.36.60 - 8030 html &lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>配置完成后重启Nginx服务器。</p>
<p>把<code>121.43.178.226</code>服务器作为代理服务器，做如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /usr/local/nginx/conf/conf.d/cache.conf</span><br><span class="line"></span><br><span class="line">proxy_cache_path /usr/local/nginx/cache_temp levels=2:2 keys_zone=cache_zone:30m max_size=2g inactive=60m use_temp_path=off;</span><br><span class="line"></span><br><span class="line">upstream cache_server &#123;</span><br><span class="line">    server 1.12.36.60:8020;</span><br><span class="line">    server 1.12.36.60:8030;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name cache.com;</span><br><span class="line">    location /cache/ &#123;</span><br><span class="line">        proxy_cache cache_zone; # 设置缓存内存，上面配置中已经定义好的</span><br><span class="line">        proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟</span><br><span class="line">        proxy_cache_key $request_uri; # 缓存文件的key为请求的URI</span><br><span class="line">        add_header Nginx-Cache-Status $upstream_cache_status; # 把缓存状态设置为头部信息，响应给客户端</span><br><span class="line">        proxy_pass http://cache_server/; # 代理转发</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后重启Nginx服务器。</p>
<p>测试：</p>
<img src="image-20240122125955060.png" alt="image-20240122125955060" />

<p>此时可以在<code>/usr/local/nginx/cache_temp</code>路径下找到相应的缓存文件。</p>
<img src="image-20240122130111070.png" alt="image-20240122130111070" />

<blockquote>
<p>对于一些实时性要求非常高的页面或数据来说，不应该设置缓存。下面来看看如何配置不缓存的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name cache.com;</span><br><span class="line">    # URI中后缀为.txt或.text的设置变量值为&quot;no cache&quot;</span><br><span class="line">    if ($request_uri ~ \.(txt|text)$) &#123;</span><br><span class="line">    	set $cache_name &quot;no cache&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /cache/ &#123;</span><br><span class="line">        proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，如果没有值则进行缓存</span><br><span class="line">        proxy_cache cache_zone; # 设置缓存内存</span><br><span class="line">        proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟</span><br><span class="line">        proxy_cache_key $request_uri; # 缓存文件的key为请求的URI</span><br><span class="line">        add_header Nginx-Cache-Status $upstream_cache_status; # 把缓存状态设置为头部信息，响应给客户端</span><br><span class="line">        proxy_pass http://cache_server/; # 代理转发</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h4><ol>
<li><p>客户端（浏览器）访问<code>https://www.baidu.com</code>；</p>
</li>
<li><p>百度服务器返回<code>HTTPS</code>使用的<code>CA</code>证书；</p>
</li>
<li><p>浏览器验证<code>CA</code>证书是否为合法证书；</p>
</li>
<li><p>验证通过，证书合法，生成一串随机数并使用公钥（证书中提供的）进行加密；</p>
</li>
<li><p>发送公钥加密后的随机数给百度服务器；</p>
</li>
<li><p>百度服务器拿到密文，通过私钥进行解密，获取到随机数（公钥加密，私钥解密，反之也可以）；</p>
</li>
<li><p>百度服务器把要发送给浏览器的内容，使用随机数进行加密后传输给浏览器；</p>
</li>
<li><p>此时浏览器可以使用随机数进行解密，获取到服务器的真实传输内容。</p>
</li>
</ol>
<p>这就是<code>HTTPS</code>的基本运作原理，对称加密和非对称加密配合使用，保证传输内容的安全性。</p>
<h4 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h4><p>下载证书的压缩文件，里面有个<code>Nginx</code>文件夹，把<code>xxx.crt</code>和<code>xxx.key</code>文件拷贝到服务器目录，再进行如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2 default_server; # SSL访问端口号为443</span><br><span class="line">    server_name fuyuan.com; # 填写绑定证书的域名（我这里是随便写的）</span><br><span class="line">    ssl_certificate /etc/nginx/https/lion.club_bundle.crt; # 证书地址</span><br><span class="line">    ssl_certificate_key /etc/nginx/https/lion.club.key; # 私钥地址</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 支持ssl协议版本，默认为后三个，主流版本是[TLSv1.2]</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root html;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此配置后就能正常访问<code>HTTPS</code>版的网站了。</p>
<h3 id="配置跨域CORS"><a href="#配置跨域CORS" class="headerlink" title="配置跨域CORS"></a>配置跨域CORS</h3><p><strong>跨域的定义</strong></p>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互，这是一个用于隔离潜在恶意文件的重要安全机制，通常不允许不同源间的读操作。</p>
<p><strong>同源的定义</strong></p>
<p>如果两个页面的协议、端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p>
<p>下面给出了与URL<code>http://store.company.com/dir/page.html</code>的源进行对比的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://store.company.com/dir2/other.html # 同源</span><br><span class="line">https://store.company.com/secure.html    # 不同源，协议不同</span><br><span class="line">http://store.company.com:81/dir/etc.html # 不同源，端口不同</span><br><span class="line">http://news.company.com/dir/other.html   # 不同源，主机不同</span><br></pre></td></tr></table></figure>

<p>不同源会有如下限制：</p>
<ul>
<li><code>Web</code>数据层面：同源策略限制了不同源的站点读取当前站点的<code>Cookie</code>、<code>IndexDB</code>、<code>LocalStorage</code>等数据。</li>
<li><code>DOM</code>层面：同源策略限制了来自不同源的<code>JavaScript</code>脚本对当前<code>DOM</code>对象读和写的操作。</li>
<li>网络层面：同源策略限制了通过<code>XMLHttpRequest</code>等方式将站点的数据发送给不同源的站点。</li>
</ul>
<p><strong>Nginx解决跨域的原理</strong></p>
<p>例如：</p>
<ul>
<li>前端服务的域名为：<code>fe.server.com</code></li>
<li>后端服务的域名为：<code>dev.server.com</code></li>
</ul>
<p>现在从<code>fe.server.com</code>对<code>dev.server.com</code>发起请求一定会出现跨域，此时我们只需启动一个Nginx服务器，将<code>server_name</code>设置为<code>fe.server.com</code>，然后设置相应的<code>location</code>以拦截前端需要跨域的请求，最后将请求代理回<code>dev.server.com</code>，具体配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name fe.server.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	proxy_pass dev.server.com;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以完美绕过浏览器的同源策略：<code>fe.server.com</code>访问Nginx的<code>fe.server.com</code>属于同源访问，而Nginx对服务端转发的请求不会触发浏览器的同源策略。</p>
<h3 id="配置开启gzip压缩"><a href="#配置开启gzip压缩" class="headerlink" title="配置开启gzip压缩"></a>配置开启gzip压缩</h3><p><code>gzip</code>是规定的三种标准<code>HTTP</code>压缩格式之一，目前绝大多数的网站都在使用<code>gzip</code>传输<code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>等资源文件。</p>
<p>对于文本文件，<code>gzip</code>的效果非常明显，开启后传输所需流量大约会降至<code>1/4 ~ 1/3</code>。值得注意的是，并不是每个浏览器都支持<code>gzip</code>的，那么如何知道客户端是否支持<code>gzip</code>呢——客户端通过请求头中的<code>Accept-Encoding</code>来标识对压缩的支持。</p>
<img src="image-20240118173142953.png" alt="image-20240118173142953" />

<p>启用<code>gzip</code>同时需要客户端和服务端的支持，如果客户端支持<code>gzip</code>的解析，那么只要服务端能够返回<code>gzip</code>的文件就可以启用<code>gzip</code>了，我们可以通过Nginx的配置来让服务端支持<code>gzip</code>。下面的<code>respone</code>中<code>content-encoding:gzip</code>表明服务端开启了<code>gzip</code>的压缩方式。</p>
<img src="image-20240118173556589.png" alt="image-20240118173556589" />

<p>在<code>/usr/local/nginx/conf/conf.d/</code>文件夹中新建配置文件<code>gzip.conf</code>，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认 off，是否开启 gzip</span><br><span class="line">gzip on; </span><br><span class="line"># 要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用</span><br><span class="line">gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line"># ---- 以上两个参数开启就可以支持gzip压缩了 ---- #</span><br><span class="line"></span><br><span class="line"># 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容</span><br><span class="line">gzip_static on;</span><br><span class="line"></span><br><span class="line"># 默认 off，Nginx 做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩</span><br><span class="line">gzip_proxied any;</span><br><span class="line"></span><br><span class="line"># 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩</span><br><span class="line">gzip_vary on;</span><br><span class="line"></span><br><span class="line"># gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line"></span><br><span class="line"># 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得</span><br><span class="line">gzip_buffers 16 8k;</span><br><span class="line"></span><br><span class="line"># 允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大</span><br><span class="line"># gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line"># 默认 1.1，启用 gzip 所需的 HTTP 最低版本</span><br><span class="line">gzip_http_version 1.1;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置<code>gzip_static</code>后报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZbp13q6vsoi3olxdbo7syZ sbin]<span class="comment"># ./nginx -s reload</span></span><br><span class="line">nginx: [emerg] unknown directive <span class="string">&quot;gzip_static&quot;</span> <span class="keyword">in</span> /usr/local/nginx/conf/conf.d/web.conf:2</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用./nginx -V查看当前nginx的配置信息，看有没有配置--with-http_gzip_static_module</span><br><span class="line">[root@iZbp13q6vsoi3olxdbo7syZ sbin]# ./nginx -V</span><br><span class="line">nginx version: nginx/1.15.8</span><br><span class="line">built by gcc 9.3.1 20200408 (Red Hat 9.3.1-2) (GCC)</span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --with-http_ssl_module</span><br><span class="line"></span><br><span class="line"># 通过以上信息中的configure arguments看出我们没有配置该信息，这时需要我们进入原来nginx解压的目录中，进行配置并重新安装。</span><br><span class="line">[root@iZbp13q6vsoi3olxdbo7syZ sbin]# cd /usr/local/nginx-1.15.8</span><br><span class="line">[root@iZbp13q6vsoi3olxdbo7syZ nginx-1.15.8]# ./configure --with-http_ssl_module --with-http_gzip_static_module</span><br><span class="line">[root@iZbp13q6vsoi3olxdbo7syZ nginx-1.15.8]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
</blockquote>
<p>也可以通过前端构建工具例如<code>webpack</code>、<code>rollup</code>等在打生产包时就做好<code>gzip</code>压缩，然后放到Nginx服务器中，这样可以减少服务器的开销，加快访问速度。</p>
<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>前端使用Nginx做反向代理，如果后端服务器宕掉的话，Nginx是不能把这台<code>real server</code>踢出<code>upstream</code>的，所以还会有请求转发到后端的这台<code>real server</code>上面去，虽然Nginx可以在<code>localtion</code>中启用<code>proxy_next_upstream</code>来解决返回给用户的错误页面，但这个还是会把请求转发给这台服务器的，然后再转发给别的服务器，这样就浪费了一次转发。本次使用淘宝技术团队开发的Nginx模快<code>nginx_upstream_check_module</code>来检测后方<code>real server</code>的健康状态，如果后端服务器不可用，则所有的请求不转发到这台服务器。</p>
<p><code>nginx_upstream_check_module</code>模块专门提供负载均衡器内节点的健康检查的外部模块，通过它可以用来检测后端<code>real server</code>的健康状态。如果后端<code>real server</code>不可用，则后面的请求就不会转发到该节点上，并持续检查节点的状态。</p>
<h4 id="Nginx后端健康检查"><a href="#Nginx后端健康检查" class="headerlink" title="Nginx后端健康检查"></a>Nginx后端健康检查</h4><p>Nginx自带健康检查的缺陷：</p>
<ol>
<li>Nginx只有访问时才发起对后端节点的探测。</li>
<li>如果本次请求中节点正好出现故障，Nginx依然将请求转交给故障节点，然后再转交给健康节点进行处理。所以不会影响到这次请求的正常进行，但是会影响效率，因为多了一次转发。</li>
<li>自带模块无法做到预警。</li>
<li>被动健康检查。</li>
</ol>
<p>使用第三访模块<code>nginx_upstream_check_module</code>：</p>
<ol>
<li>区别于Nginx自带的非主动式的心跳检测，<code>nginx_upstream_check_module</code>自带一个提供主动式后端服务器心跳检测模块。</li>
<li>若健康检查包类型为<code>http</code>，在开启健康检查功能后，Nginx会根据设置的间隔向指定的后端服务器端口发送健康检查包，并根据期望的<code>http</code>回复状态码来判断服务是否健康。</li>
<li>后端真实节点不可用，则请求不会转发到故障节点。</li>
<li>故障节点恢复后，请求正常转发。</li>
</ol>
<h4 id="Nginx被动检查"><a href="#Nginx被动检查" class="headerlink" title="Nginx被动检查"></a>Nginx被动检查</h4><p>Nginx自带健康检查模块：ngx_http_upstream_module，可以做到基本的健康检查，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream health_check &#123;</span><br><span class="line">    server 1.12.36.60:8020 max_fails=1 fail_timeout=10s;</span><br><span class="line">    server 1.12.36.60:8030 max_fails=1 fail_timeout=10s;</span><br><span class="line">    # max_fails=1和fail_timeout=10s表示在单位周期为10s内，达到1次连接失败，那么将把节点标记为不可用，并等待下一个周期（同样时常为fail_timeout）再一次去请求，判断连接是否成功</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name check.com; </span><br><span class="line">    location /check &#123;</span><br><span class="line">    	proxy_pass http://health_check;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：Nginx只有访问时才发起对后端节点的探测。如果本次请求中节点正好出现故障，Nginx依然将请求转交给故障节点，然后再转交给健康节点进行处理。所以不会影响到这次请求的正常进行，但是会影响效率，因为多了一次转发。</p>
<h4 id="Nginx主动检查"><a href="#Nginx主动检查" class="headerlink" title="Nginx主动检查"></a>Nginx主动检查</h4><p>Nignx定时主动地去ping后端的服务列表，当发现某服务出现异常时，把该服务从健康列表中移除，当发现某服务恢复时，又能够将该服务加回健康列表中。</p>
<p><strong>安装nginx_upstream_check_module模块</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载安装包</span></span><br><span class="line">wget https://codeload.github.com/yaoweibin/nginx_upstream_check_module/zip/master</span><br><span class="line"></span><br><span class="line">unzip master &amp;&amp; <span class="built_in">rm</span> -f maste</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/local/nginx-1.15.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打上nginx_upstream_check_module补丁</span></span><br><span class="line">patch -p1 &lt; /usr/local/nginx_upstream_check_module-master/check_1.16.1+.patch</span><br><span class="line"></span><br><span class="line">./configure --add-module=/usr/local/nginx_upstream_check_module-master --with-http_ssl_module --with-http_gzip_static_module</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<p>Nginx提供了三种HTTP服务健康检查方案供用户选择：</p>
<ol>
<li><p>TCP层默认检查方案：定时与后端服务建立一条tcp链接，链接建立成功则认为服务节点是健康的。</p>
</li>
<li><p>HTTP层默认检查方案：</p>
<p>TCP层检查有一定的局限性：</p>
<ul>
<li>很多HTTP服务是带状态的，端口处于listen状态并不能代表服务已经完成预热。</li>
<li>不能真实反映服务内部处理逻辑是否产生拥堵。</li>
</ul>
<p>这时可以选择http层健康检查，会向服务发送一个http请求GET &#x2F; HTTP&#x2F;1.0\r\n\r\n，返回状态是2xx或3xx时认为后端服务正常。</p>
</li>
<li><p>自定义方案：nginx_upstream_check_module模块。</p>
<p>可根据下文描述自定义检查方案。</p>
</li>
</ol>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream health_check1 &#123;</span><br><span class="line">    server 1.12.36.60:8020;</span><br><span class="line">    server 1.12.36.60:8030;</span><br><span class="line">    check interval=3000 rise=2 fall=5 timeout=1000 type=http;</span><br><span class="line">    check_http_send &quot;HEAD / HTTP/1.0\r\n\r\n&quot;;</span><br><span class="line">    check_http_expect_alive http_2xx http_3xx;</span><br><span class="line">&#125;</span><br><span class="line">upstream health_check2 &#123;</span><br><span class="line">    server 1.12.36.60:8020;</span><br><span class="line">    server 1.12.36.60:8030;</span><br><span class="line">    check interval=3000 rise=2 fall=5 timeout=1000 type=http;</span><br><span class="line">    check_keepalive_requests 100;</span><br><span class="line">    check_http_send &quot;HEAD / HTTP/1.1\r\nConnection: keep-alive\r\n\r\n&quot;;</span><br><span class="line">    check_http_expect_alive http_2xx http_3xx;</span><br><span class="line">&#125;</span><br><span class="line">server &#123; </span><br><span class="line">    listen 80;</span><br><span class="line">    location /check1 &#123;</span><br><span class="line">    	proxy_pass http://health_check1/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /check2 &#123;</span><br><span class="line">    	proxy_pass http://health_check2/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /status &#123;</span><br><span class="line">        check_status;</span><br><span class="line">        access_log off;</span><br><span class="line">        error_log /dev/null emerg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置参数详解</strong></p>
<ol>
<li><p><code>check</code>：用于打开后端服务器的健康检查功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Syntax: check interval=milliseconds [fall=count] [rise=count] [timeout=milliseconds] [default_down=true|false] [type=tcp|http|ssl_hello|mysql|ajp] [port=check_port]</span><br><span class="line">Default: 如果没有配置参数，默认值为：interval=30000 fall=5 rise=2 timeout=1000 default_down=true type=tcp</span><br><span class="line">Context: upstream</span><br></pre></td></tr></table></figure>

<ul>
<li><code>interval</code>：向后端发送的健康检查包的间隔，单位为毫秒。</li>
<li><code>fall（fall_count）</code>：如果连续失败次数达到<code>fall_count</code>，服务器就被认为是<code>down</code>。</li>
<li><code>rise（rise_count）</code>：如果连续成功次数达到<code>rise_count</code>，服务器就被认为是<code>up</code>。</li>
<li><code>timeout</code>：后端健康请求的超时时间。</li>
<li><code>default_down</code>：设定初始时服务器的状态，如果是<code>true</code>，就说明默认是<code>down</code>的，如果是<code>false</code>，就是<code>up</code>的。默认值为<code>true</code>，也就是一开始服务器认为是不可用，要等健康检查包达到一定成功次数以后才会被认为是健康的。</li>
<li><code>type</code>：健康检查包的类型，现在支持以下多种类型    <ul>
<li><code>tcp</code>：简单的<code>tcp</code>连接，如果连接成功，就说明后端正常。</li>
<li><code>ssl_hello</code>：发送一个初始的<code>SSL hello</code>包并接受服务器的<code>SSL hello</code>包。</li>
<li><code>http</code>：发送<code>http</code>请求，通过后端的回复包状态来判断后端是否存活。</li>
<li><code>mysql</code>：与<code>mysql</code>服务器进行连接，通过接收服务器的<code>greeting</code>包来判断后端是否存活。</li>
<li><code>ajp</code>：向后端发送<code>AJP</code>协议的<code>Cping</code>包，通过接收<code>Cpong</code>包来判断后端是否存活。</li>
<li><code>port</code>：指定后端服务器的检查端口。可以指定不同于真实服务的后端服务器端口，比如后端提供的是443端口的应用，我们可以去检查80端口的状态来判断后端健康状况。默认为<code>0</code>，表示跟后端提供真实服务的端口一致。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>check_keepalive_requests</code>：配置一个连接发送的请求数，其默认值为1，表示完成1次请求后关闭连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Syntax: check_keepalive_requests request_num</span><br><span class="line">Default: 1</span><br><span class="line">Context: upstream</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>check_http_send</code>：配置<code>http</code>健康检查包发送的请求内容。为了减少传输数据量，推荐采用<code>HEAD</code>方法。</p>
<p>当采用长连接进行健康检查时，需在该指令中添加<code>keep-alive</code>请求头，如：<code>HEAD / HTTP/1.1\r\nConnection: keep-alive\r\n\r\n</code>。</p>
<p>同时，在采用<code>GET</code>方法的情况下，请求<code>uri</code>的<code>size</code>不宜过大，确保可以在1个<code>interval</code>内传输完成，否则会被健康检查模块视为后端服务器或网络异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Syntax: check_http_send http_packet</span><br><span class="line">Default: &quot;GET / HTTP/1.0\r\n\r\n&quot;</span><br><span class="line">Context: upstream</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>check_http_expect_alive</code>：指定<code>http</code>回复的成功状态，默认认为<code>2XX</code>和<code>3XX</code>的状态是健康的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Syntax: check_http_expect_alive [ http_2xx | http_3xx | http_4xx | http_5xx ]</span><br><span class="line">Default: http_2xx | http_3xx</span><br><span class="line">Context: upstream</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>check_shm_size</code>：所有的后端服务器健康检查状态都存于共享内存中，该参数用于设置共享内存的大小，默认为<code>1M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Syntax: check_shm_size size</span><br><span class="line">Default: 1M</span><br><span class="line">Context: http</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>check_status</code>：显示服务器的健康状态页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Syntax: check_status [html|csv|json]</span><br><span class="line">Default: check_status html</span><br><span class="line">Context: location</span><br></pre></td></tr></table></figure>

<p>可以配置显示页面的格式，支持的格式有：<code>html</code>、<code>csv</code>、 <code>json</code>。默认类型为<code>html</code>。</p>
<p>也可以通过请求的参数来指定格式，假设<code>/status</code>为状态页面的<code>URI</code>，<code>format</code>参数改变页面的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/status?format=html</span><br><span class="line">/status?format=csv</span><br><span class="line">/status?format=json</span><br></pre></td></tr></table></figure>

<p>同时也可以通过<code>status</code>参数来获取相同服务器状态的列表，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/status?format=html&amp;amp;status=down</span><br><span class="line">/status?format=csv&amp;amp;status=up</span><br></pre></td></tr></table></figure>

<p>下面是一个<code>html</code>状态页面的例子（<code>server number</code>是后端服务器的数量，<code>generation</code>是<code>Nginx reload</code>的次数。<code>Index</code>是服务器的索引，<code>Upstream</code>是配置中<code>upstream</code>的名称，<code>Name</code>是服务器<code>IP</code>，<code>Status</code>是服务器的状态，<code>Rise</code>是服务器连续检查成功的次数，<code>Fall</code>是连续检查失败的次数，<code>Check type</code>是检查的方式，<code>Check port</code>是后端专门为健康检查设置的端口）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Strict//EN</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;html xmlns=&quot;</span>http://www.w3.org/1999/xhtml<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;head&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;title&gt;Nginx http upstream check status&lt;/title&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;/head&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;body&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;h1&gt;Nginx http upstream check status&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;h2&gt;Check upstream server number: 1, generation: 3&lt;/h2&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;table style=&quot;</span>background-color:white<span class="string">&quot; cellspacing=&quot;</span>0<span class="string">&quot; cellpadding=&quot;</span>3<span class="string">&quot; border=&quot;</span>1<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">            &lt;tr bgcolor=&quot;</span>#C0C0C0<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;th&gt;Index&lt;/th&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;th&gt;Upstream&lt;/th&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;th&gt;Name&lt;/th&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;th&gt;Status&lt;/th&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;th&gt;Rise counts&lt;/th&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;th&gt;Fall counts&lt;/th&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;th&gt;Check type&lt;/th&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;th&gt;Check port&lt;/th&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">            &lt;/tr&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">            &lt;tr&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;td&gt;0&lt;/td&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;td&gt;backend&lt;/td&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;td&gt;106.187.48.116:80&lt;/td&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;td&gt;up&lt;/td&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;td&gt;39&lt;/td&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;td&gt;0&lt;/td&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;td&gt;http&lt;/td&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;td&gt;80&lt;/td&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">            &lt;/tr&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;/table&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;/body&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;/html&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>下面是<code>csv</code>格式页面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,backend,106.187.48.116:80,up,46,0,http,80</span><br></pre></td></tr></table></figure>

<p>下面是<code>json</code>格式页面的例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;servers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;generation&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="attr">&quot;upstream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;backend&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;106.187.48.116:80&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;up&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;rise&quot;</span><span class="punctuation">:</span> <span class="number">58</span><span class="punctuation">,</span> <span class="attr">&quot;fall&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>状态测试</strong></p>
<img src="image-20240204104125996.png" alt="image-20240204104125996" />



<h2 id="Nginx架构"><a href="#Nginx架构" class="headerlink" title="Nginx架构"></a>Nginx架构</h2><h3 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h3><p>多进程结构Nginx的进程模型图：</p>
<img src="image-20240119081335618.png" alt="image-20240119081335618" />

<p>多进程中Nginx进程架构如上图所示，会有一个父进程（Master Process），它会有很多子进程（Child Processes）。</p>
<ol>
<li><code>Master Process</code>用来管理子进程，其本身并不真正处理用户请求。<ul>
<li>某个子进程宕掉，它会向<code>Master</code>进程发送一条消息，表明自己不可用了，此时<code>Master</code>进程会新起一个子进程。</li>
<li>某个配置文件被修改后<code>Master</code>进程会去通知<code>work</code>进程获取新的配置信息，也就是我们所说的热部署。</li>
</ul>
</li>
<li>子进程间通过共享内存的方式进行通信。</li>
</ol>
<h3 id="配置文件重载原理"><a href="#配置文件重载原理" class="headerlink" title="配置文件重载原理"></a>配置文件重载原理</h3><p><code>reload</code>重载配置文件的流程：</p>
<ol>
<li>向<code>master</code>进程发送<code>HUP</code>信号（<code>reload</code>命令）；</li>
<li><code>master</code>进程检查配置语法是否正确；</li>
<li><code>master</code>进程打开监听端口；</li>
<li><code>master</code>进程使用新的配置文件启动新的<code>worker</code>子进程；</li>
<li><code>master</code>进程向老的<code>worker</code>子进程发送<code>QUIT</code>信号；</li>
<li>老的<code>worker</code>进程关闭监听句柄，处理完当前连接后关闭进程；</li>
<li>整个过程<code>Nginx</code>始终处于平稳运行中，实现了平滑升级，用户无感知。</li>
</ol>
<h3 id="Nginx模块化管理机制"><a href="#Nginx模块化管理机制" class="headerlink" title="Nginx模块化管理机制"></a>Nginx模块化管理机制</h3><p>Nginx内部结构是由核心部分和一系列的功能模块所组成，这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。Nginx的模块是互相独立的，低耦合高内聚。</p>
<img src="image-20240119082950052.png" alt="image-20240119082950052" />
</article><div class="tag_share"><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小辑轻舟</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuliangcong"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">正向代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">反向代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">3.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB"><span class="toc-number">4.</span> <span class="toc-text">动静分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">5.</span> <span class="toc-text">环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">5.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">5.3.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">配置文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6main%E6%AE%B5%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">配置文件main段核心参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6events%E6%AE%B5%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">配置文件events段核心参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#server-name%E6%8C%87%E4%BB%A4"><span class="toc-number">6.4.</span> <span class="toc-text">server_name指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#root"><span class="toc-number">6.5.</span> <span class="toc-text">root</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alias"><span class="toc-number">6.6.</span> <span class="toc-text">alias</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#location"><span class="toc-number">6.7.</span> <span class="toc-text">location</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rewrite"><span class="toc-number">6.8.</span> <span class="toc-text">rewrite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E6%8C%87%E4%BB%A4"><span class="toc-number">6.9.</span> <span class="toc-text">if指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#autoindex"><span class="toc-number">6.10.</span> <span class="toc-text">autoindex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E9%85%8D%E7%BD%AE"><span class="toc-number">7.</span> <span class="toc-text">实战配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#upstream"><span class="toc-number">7.1.</span> <span class="toc-text">upstream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-pass"><span class="toc-number">7.2.</span> <span class="toc-text">proxy_pass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">配置反向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1"><span class="toc-number">7.3.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2"><span class="toc-number">7.3.2.</span> <span class="toc-text">实例2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">7.4.</span> <span class="toc-text">配置负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">7.4.1.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.2.</span> <span class="toc-text">hash算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ip-hash"><span class="toc-number">7.4.3.</span> <span class="toc-text">ip_hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.4.</span> <span class="toc-text">最小连接数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%87%8D"><span class="toc-number">7.4.5.</span> <span class="toc-text">权重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83"><span class="toc-number">7.4.6.</span> <span class="toc-text">灰度发布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%BC%93%E5%AD%98"><span class="toc-number">7.5.</span> <span class="toc-text">配置缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS"><span class="toc-number">7.6.</span> <span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.6.1.</span> <span class="toc-text">HTTPS工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%AF%81%E4%B9%A6"><span class="toc-number">7.6.2.</span> <span class="toc-text">配置证书</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9FCORS"><span class="toc-number">7.7.</span> <span class="toc-text">配置跨域CORS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%BC%80%E5%90%AFgzip%E5%8E%8B%E7%BC%A9"><span class="toc-number">7.8.</span> <span class="toc-text">配置开启gzip压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">7.9.</span> <span class="toc-text">健康检查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx%E5%90%8E%E7%AB%AF%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">7.9.1.</span> <span class="toc-text">Nginx后端健康检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx%E8%A2%AB%E5%8A%A8%E6%A3%80%E6%9F%A5"><span class="toc-number">7.9.2.</span> <span class="toc-text">Nginx被动检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx%E4%B8%BB%E5%8A%A8%E6%A3%80%E6%9F%A5"><span class="toc-number">7.9.3.</span> <span class="toc-text">Nginx主动检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E6%9E%B6%E6%9E%84"><span class="toc-number">8.</span> <span class="toc-text">Nginx架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">进程结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">配置文件重载原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">8.3.</span> <span class="toc-text">Nginx模块化管理机制</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/15/Mybatis-Plus/" title="Mybatis-Plus">Mybatis-Plus</a><time datetime="2024-03-15T11:25:37.000Z" title="发表于 2024-03-15 19:25:37">2024-03-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/06/Nginx/" title="Nginx">Nginx</a><time datetime="2024-02-06T12:51:43.000Z" title="发表于 2024-02-06 20:51:43">2024-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/28/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/" title="网页布局方式">网页布局方式</a><time datetime="2024-01-28T10:35:05.000Z" title="发表于 2024-01-28 18:35:05">2024-01-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/28/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/" title="CSS预处理器">CSS预处理器</a><time datetime="2024-01-28T10:09:08.000Z" title="发表于 2024-01-28 18:09:08">2024-01-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/28/Redis/" title="Redis">Redis</a><time datetime="2024-01-28T09:40:41.000Z" title="发表于 2024-01-28 17:40:41">2024-01-28</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgb(116,116,116)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 小辑轻舟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p style="letter-spacing:2px; margin-top:0">平明拂剑朝天去，薄暮垂鞭醉酒归！<p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>