<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis | 知行记</title><meta name="author" content="小辑轻舟"><meta name="copyright" content="小辑轻舟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是字符串（String）、列表（List）、集合（Set）、哈希（Hash）和有序集合（Zset）等类型。 特点：  Redis支持数">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://liuliangcong.github.io/2024/01/28/Redis/index.html">
<meta property="og:site_name" content="知行记">
<meta property="og:description" content="简介Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是字符串（String）、列表（List）、集合（Set）、哈希（Hash）和有序集合（Zset）等类型。 特点：  Redis支持数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liuliangcong.github.io/images/avatar.png">
<meta property="article:published_time" content="2024-01-28T09:40:41.000Z">
<meta property="article:modified_time" content="2024-01-28T10:03:16.793Z">
<meta property="article:author" content="小辑轻舟">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liuliangcong.github.io/images/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://liuliangcong.github.io/2024/01/28/Redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-28 18:03:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="知行记"><span class="site-name">知行记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-28T09:40:41.000Z" title="发表于 2024-01-28 17:40:41">2024-01-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-28T10:03:16.793Z" title="更新于 2024-01-28 18:03:16">2024-01-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>100分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是字符串（String）、列表（List）、集合（Set）、哈希（Hash）和有序集合（Zset）等类型。</p>
<p>特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list、set、hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave（主从）模式的数据备份。</li>
<li>Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p>
<p>安装步骤：</p>
<ol>
<li><p>下载Redis-x64-xxx.zip压缩包，解压并将文件夹重新命名为redis。</p>
</li>
<li><p>打开命令行窗口，切换到redis安装目录下，执行下方命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.\redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure>

<img src="image-20230522093938878.png" alt="image-20230522093938878" style="zoom:80%;" />

<blockquote>
<p>命令中的<code>redis.windows.conf</code>可以省略，如果省略则表示使用默认配置。</p>
</blockquote>
</li>
<li><p>测试：重新打开一个命令行窗口并切换到redis安装目录下，<code>原先的命令行窗口不关闭</code>，否则无法访问服务端。执行下方命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.\redis-cli.exe -h 127.0.0.1 -p 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">(base) PS F:\environment\redis&gt; .\redis-cli.exe -h 127.0.0.1 -p 6379</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> myKey abc <span class="comment"># 设置键值对</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get myKey <span class="comment"># 取出键值对</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><p>下载地址：<a target="_blank" rel="noopener" href="http://redis.io/download">http://redis.io/download</a></p>
<p>安装步骤：</p>
<ol>
<li><p>下载并安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-6.0.8.tar.gz</span><br><span class="line">tar xzf redis-6.0.8.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-6.0.8</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>执行完<code>make</code>命令，redis-6.0.8的<code>src</code>目录下会出现编译后的redis服务程序<code>redis-server</code>，还有用于测试的客户端程序<code>redis-cli</code>。</p>
<blockquote>
<p>安装redis时出现以下错误：</p>
<img src="image-20230522104328462.png" alt="image-20230522104328462"/>

<p>解决方法：升级gcc到最新版本，执行下方命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">gcc -v</span><br><span class="line"><span class="comment"># 高版本的redis需要更高版本的gcc，云安装的gcc版本4.8.5，需要升级gcc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级gcc</span></span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-9 bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt;/etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>启动redis服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.0.8/src</span><br><span class="line">./redis-server</span><br></pre></td></tr></table></figure>

<img src="image-20230522104811400.png" alt="image-20230522104811400"/>

<p>这种方式启动redis时使用的是默认配置，也可以通过启动参数指定配置文件，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-server ../redis.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>redis.conf</code>是一个默认的配置文件，可以根据需要使用自己的配置文件。</p>
<p>redis默认不是后台启动，可修改配置文件进行设置。</p>
<img src="image-20230627141310408.png" alt="image-20230627141310408"/>
</blockquote>
</li>
<li><p>测试：启动redis服务进程后，就可以使用测试客户端程序<code>redis-cli</code>和redis服务进行交互了。执行下方命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.0.8/src</span><br><span class="line">./redis-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="built_in">set</span> myKey abc <span class="comment"># 设置键值对</span></span><br><span class="line">get myKey <span class="comment"># 取出键值对</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看redis进程：<code> ps -ef|grep redis</code></p>
<img src="image-20230627141633537.png" alt="image-20230627141633537"/>

<p>关闭redis服务：</p>
<ul>
<li>方式一：在redis-cli下执行shutdown命令。</li>
<li>方式二：使用kill命令停止redis进程，即执行<code>kill -9 pid</code>命令。</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h2><p>Redis配置文件位于Redis安装目录下，Windows中文件名为<code>redis.windows.conf</code>，Linux中文件名为<code>redis.conf</code>，可以通过<code>config</code>命令查看或编辑配置项。</p>
<p>查看配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">config get config_setting_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">127.0.0.1:6379&gt; config get loglevel</span><br><span class="line">1) <span class="string">&quot;loglevel&quot;</span></span><br><span class="line">2) <span class="string">&quot;notice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用*号获取所有配置项</span></span><br><span class="line">127.0.0.1:6379&gt; config get *</span><br></pre></td></tr></table></figure>

<p>编辑配置：可以通过修改redis.conf文件或使用<code>config set</code>命令来修改配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">config <span class="built_in">set</span> config_setting_name new_config_value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> loglevel <span class="string">&quot;notice&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get loglevel</span><br><span class="line">1) <span class="string">&quot;loglevel&quot;</span></span><br><span class="line">2) <span class="string">&quot;notice&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis支持五种数据类型：</p>
<ul>
<li>字符串：String</li>
<li>列表：List</li>
<li>集合：Set</li>
<li>哈希：Hash</li>
<li>有序集合：Zset</li>
</ul>
<blockquote>
<p>注意：这里说的数据类型指的是value的数据类型，而key的类型都是字符串。</p>
</blockquote>
<h3 id="键（Key）"><a href="#键（Key）" class="headerlink" title="键（Key）"></a>键（Key）</h3><p>常用命令：</p>
<ul>
<li>keys *：查看当前库所有的key</li>
<li>exists key：判断key是否存在</li>
<li>keys pattern：查找所有符合给定模式pattern的key</li>
<li>del key [key …]：删除一个或多个key</li>
<li>type key：返回key所储存的值对应的类型</li>
<li>del key：删除指定的key，阻塞删除</li>
<li>unlink key：删除指定的key，非阻塞删除，只是将键与键空间断开连接，实际的删除将稍后异步进行</li>
<li>expire key seconds：为key设置过期时间，以秒计</li>
<li>pexpire key millisecnds：为key设置过期时间，以毫秒计</li>
<li>persist key：移除key的过期时间，key将持久保持</li>
<li>ttl key：以秒为单位返回key的剩余过期时间，-1：表示永不过期，-2：表示已过期</li>
<li>pttl key：以毫秒为单位返回key的剩余过期时间</li>
<li>rename key newkey：修改key的名称，若newkey已存在，则覆盖</li>
<li>renamenx key newkey：仅当newkey不存在时，将key改名为newkey</li>
<li>select dbindex：切换数据库[0-15]，默认为0</li>
<li>dbsize：查看当前数据库key的数量</li>
<li>flushdb：清空当前库</li>
<li>flushall：通杀全部库</li>
<li>move key db：将当前数据库的key移动到指定的数据库db中</li>
<li>randomkey：从当前数据库中随机返回一个key</li>
</ul>
<h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><p><strong>简介</strong></p>
<p>String类型是Redis最基本的数据类型，String类型的值最大能存储512MB。</p>
<p>String类型是二进制安全的，意思是Redis的String可以包含任何数据，比如图片或者序列化的对象。</p>
<p>添加键值对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value [expiration EX seconds|PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure>

<ul>
<li>EX seconds：将键的过期时间设置为seconds秒。执行SET key value EX seconds的效果等同于执行SETEX key seconds value。</li>
<li>PX milliseconds：将键的过期时间设置为milliseconds毫秒。执行SET key value PX milliseconds的效果等同于执行PSETEX key milliseconds value。</li>
<li>NX：只在键不存在时，才对键进行设置操作。执行SET key value NX的效果等同于执行SETNX key value。</li>
<li>XX：只在键已经存在时，才对键进行设置操作。</li>
</ul>
<blockquote>
<p>在Redis 2.6.12版本以前，SET命令总是返回OK。从Redis 2.6.12版本开始，SET命令只在设置操作成功完成时才返回OK；如果命令使用了NX或者XX选项，但是因为条件没达到而造成设置操作未执行，那么命令将返回nil。</p>
<p>注意：value中若包含空格、特殊字符，需用双引号包裹。</p>
</blockquote>
<p><strong>常用命令</strong></p>
<ul>
<li><p>get key：获取key对应的value。</p>
</li>
<li><p>setnx key value：只有在key不存在时设置key的值。</p>
</li>
<li><p>append key value：如果key已存在且是一个字符串，则将value追加到原值的末尾；若key不存在，则设置该键值对。</p>
</li>
<li><p>strlen key：返回key所存储的字符串值的长度。</p>
</li>
<li><p>incr key：将key中存储的数字值增一，值需要为整形，否则会报错。若key不存在，则自动创建，且值为1。</p>
<p>decr key：将key中存储的数字值减一，值需要为整形，否则会报错。若key不存在，则自动创建，且值为-1。</p>
</li>
<li><p>incrby key increment：将key存储的值加上给定值increment（整形），key存储的值需要为整形。若key不存在，则相当于在0的基础上进行增加。</p>
<p>decrby key decrement：将key存储的值减去给定值increment（整形），key存储的值需要为整形。若key不存在，则相当于在0的基础上进行减少。</p>
<p>incrbyfloat key increment：将key存储的值加上给定的浮点型增量值increment，key存储的值可以是整形或浮点型。</p>
</li>
<li><p>mset key value [key value …]：设置一个或多个键值对。</p>
<p>mget key [key …]：获取一个或多个key对应的值。</p>
</li>
<li><p>msetnx key value [key value …]：设置一个或多个键值对，当且仅当所有给定的key都不存在。</p>
<blockquote>
<p>原子性操作，要么都成功，要么都失败。</p>
</blockquote>
</li>
<li><p>getrange key start end：返回key从start到end位置的值（包括结束位置）。</p>
</li>
<li><p>setrange key offset value：从偏移量offset位置开始，用value替换key相应位置的值。</p>
</li>
<li><p>setex key seconds value：将value关联到key，并将key的过期时间设置为seconds，以秒为单位。</p>
<p>psetex key milliseconds value：与setex命令相似，但它以毫秒为单位。</p>
</li>
<li><p>getset key value：将key的值设置为value，并返回key的旧值。若key不存在，则将key的值设置为value，并返回nil。</p>
</li>
</ul>
<p><strong>数据结构</strong></p>
<p>String的数据结构为简单动态字符串（Simple Dynamic String，缩写SDS），是可以修改的字符串，内部结构上类似于Java的ArrayList，采用分配冗余空间的方式来减少内存的频繁分配。</p>
<img src="image-20230815204806466.png" alt="image-20230815204806466" style="zoom:80%;" />

<p>如上图所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次会多扩容1M的空间。</p>
<h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><p><strong>简介</strong></p>
<p>列表：单键多值。</p>
<p>Redis列表是简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部或尾部，其底层为<code>双向链表</code>，对两端的操作性能很高，通过索引下标操作中间节点性能较差。</p>
<p>一个列表最多可以存储2^32^ - 1个元素。</p>
<p><strong>常用命令</strong></p>
<ul>
<li><p>lpush key value [value …]：将一个或多个值插入到列表头部。</p>
<p>rpush key value [value …]：将一个或多个值插入到列表尾部。</p>
<p>lpushx key value：将一个值插入到已存在的列表头部。</p>
<p>rpushx key value：将一个值插入到已存在的列表尾部。</p>
</li>
<li><p>llen key：获取列表长度。如果key不存在，则key被解释为一个空列表，返回0。</p>
</li>
<li><p>lrange key start stop：返回列表指定区间内的元素，可以使用负数下标，以-1表示列表的最后一个元素，-2表示列表的倒数第二个元素。</p>
</li>
<li><p>lindex key index：获取指定位置的元素，可以使用负数下标。如果下标越界，则返回nil。</p>
</li>
<li><p>lpop key：移出并获取列表的第一个元素。</p>
<p>rpop key：移出并获取列表的最后一个元素。</p>
</li>
<li><p>rpoplpush source destination：移除并获取列表的最后一个元素，并将该元素添加到另一个列表的头部。</p>
</li>
<li><p>lset key index value：替换指定位置的值。当index参数超出范围，或对一个空列表（key不存在）进行lset操作时，返回一个错误。</p>
</li>
<li><p>linsert key BEFORE|AFTER pivot value：将值value插入到列表key当中，位于值pivot之前或之后。</p>
<blockquote>
<p>当pivot不存在于列表key时，不执行任何操作，返回-1。</p>
<p>当key不存在时，key被视为空列表，不执行任何操作。</p>
<p>如果key不存在或为空列表，返回0。</p>
</blockquote>
</li>
<li><p>lrem key count value：根据参数count的值，移除列表中与参数value相等的元素。</p>
<blockquote>
<p>count的值可以是以下几种：</p>
<ul>
<li>count &gt; 0：从表头开始向表尾搜索，移除与value相等的元素，数量为count。</li>
<li>count &lt; 0：从表尾开始向表头搜索，移除与value相等的元素，数量为count的绝对值。</li>
<li>count &#x3D; 0：移除表中所有与value相等的值。</li>
</ul>
<p>返回值为被移除元素的数量。</p>
<p>因为不存在的key被视作空列表，所以当key不存在时，返回0。</p>
</blockquote>
</li>
<li><p>ltrim key start stop：对列表进行修剪，即只保留指定区间内的元素，不在区间内的元素都将被删除。</p>
</li>
</ul>
<p><strong>数据结构</strong></p>
<p>List的数据结构为快速链表quickList。</p>
<p>在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也就是压缩列表，它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当列表元素比较多的时候才会改成quickList。因为普通的链表需要的附加指针空间太大，会比较浪费空间，比如这个列表里存储的只是int类型的数，结构上还需要2个额外的指针prev和next。</p>
<img src="image-20230817134839085.png" alt="image-20230817134839085"/>

<p>redis将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist使用双向指针串起来使用，这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><p><strong>简介</strong></p>
<p>redis的set是string类型的无序集合，底层实际上是一个value为null的hash表，因此添加、删除、查找的复杂度都是O(1)。</p>
<p>集合成员唯一，且集合中最大成员数为2^32^ - 1。</p>
<p><strong>常用命令</strong></p>
<ul>
<li><p>sadd key member [member …]：向集合添加一个或多个成员。</p>
</li>
<li><p>smembers key：返回集合中的所有成员。</p>
</li>
<li><p>scard key：获取集合的成员数，当key不存在时返回0。</p>
</li>
<li><p>sismember key member：判断member元素是否是集合key的成员，返回值为0或1。</p>
</li>
<li><p>srem key member [member …]：移除集合中一个或多个成员，不存在的成员会被忽略。</p>
</li>
<li><p>spop key [count]：移除集合中一个或多个随机元素，移除后会返回被移除的元素。当key不存在或key是空集时，返回nil。</p>
</li>
<li><p>srandmember key [count]：返回集合中一个或多个随机元素。</p>
<blockquote>
<p>只提供key参数时返回一个元素；如果集合为空，返回nil。</p>
<p>如果提供了count参数，那么返回一个数组；如果集合为空，返回空数组。</p>
</blockquote>
</li>
<li><p>smove source destination member：将member元素从source集合移动到destination集合。</p>
<blockquote>
<p>smove是原子性操作。</p>
<p>如果source集合不存在或不包含指定的member元素，则smove命令不执行任何操作，仅返回0。否则member元素从source集合中被移除，并添加到destination集合中去。</p>
<p>当destination集合已经包含member元素时，smove命令只是简单地将source集合中的member元素删除。</p>
</blockquote>
</li>
<li><p>sinter key [key …]：返回给定集合的交集。</p>
<p>sinterstore destination key [key …]：将给定集合之间的交集存储在指定的集合中。如果指定的集合已存在，则将其覆盖。</p>
</li>
<li><p>sunion key [key …]：返回给定集合的并集，并自动去重。</p>
<p>sunionstore destination key [key …]：将给定集合之间的并集存储在指定的集合中。如果指定的集合已存在，则将其覆盖。</p>
</li>
<li><p>sdiff key [key …]：返回第一个集合与其他集合之间的差异，即第一个集合中独有的元素。不存在的集合key将视为空集。</p>
<p>sdiffstore destination key [key …]：将给定集合之间的差集存储在指定的集合中。如果指定的集合已存在，则将其覆盖。</p>
</li>
</ul>
<p><strong>数据结构</strong></p>
<p>set的数据结构是字典，字典是用hash表实现的。</p>
<p>Java中的HashSet的内部实现使用HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样的，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h3 id="哈希（Hash）"><a href="#哈希（Hash）" class="headerlink" title="哈希（Hash）"></a>哈希（Hash）</h3><p><strong>简介</strong></p>
<p>Redis hash是一个键值对集合。</p>
<p>Redis hash是一个String类型的字段field和值value的映射表，适用于存储对象，每个hash可以存储2^32^ - 1个键值对（40多亿）。</p>
<p><strong>常用命令</strong></p>
<ul>
<li><p>hset key field value：将哈希表key中的字段field的值设为value。</p>
<blockquote>
<p>可设置多个field，例如：hset user name ready age 30</p>
</blockquote>
<p>hmset key field value [field value …]：将多个field-value对设置到哈希表key中。</p>
</li>
<li><p>hdel key field [field …]：删除一个或多个哈希表字段。</p>
</li>
<li><p>hlen key：获取哈希表中字段的数量。</p>
</li>
<li><p>hget key field：获取哈希表中指定字段的值。</p>
<p>hgetall key：获取哈希表中所有字段和值。</p>
<p>hmget key field [field …]：获取所有给定字段的值。</p>
</li>
<li><p>hkeys key：获取哈希表中所有字段。</p>
<p>hvals key：获取哈希表所有字段对应的值。</p>
</li>
<li><p>hexists key field：检测哈希表key中指定字段是否存在，存在则返回1，否则返回0。如果key不存在，则返回0。</p>
</li>
<li><p>hincrby key field increment：为哈希表指定字段的整数值加上增量increment。</p>
<blockquote>
<p>如果字段field不存在，那么在执行命令前字段field的值被初始化为0。</p>
<p>如果哈希表key不存在，则先创建哈希表key并执行hincrby命令。</p>
</blockquote>
<p>hincrbyfloat key field increment：为哈希表指定字段的值加上给定的浮点型增量值increment。</p>
</li>
<li><p>hsetnx key field value：只有在字段field不存在时，设置哈希表字段的值。如果哈希表key不存在，则先创建哈希表key并执行hsetnx命令。</p>
</li>
</ul>
<p><strong>数据结构</strong></p>
<p>Hash类型对应的数据结构有两种：ziplist（压缩列表）、hashtable（哈希表）。</p>
<p>当field-value长度较短个数较少时使用ziplist，否则使用hashtable。</p>
<blockquote>
<p>Redis中hash可以像数据库update一样，只修改某一项属性值，而Memcached中需要取出整个字符串反序列化成对象，修改完再序列化存回去。</p>
</blockquote>
<h3 id="有序集合（Zset）"><a href="#有序集合（Zset）" class="headerlink" title="有序集合（Zset）"></a>有序集合（Zset）</h3><p><strong>简介</strong></p>
<p>Redis zset和set一样也是String类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个分数（score），Redis正是通过分数来为集合中的成员进行<code>从小到大</code>的排序。</p>
<p>zset的成员是唯一的，但分数却可以重复。</p>
<p><strong>常用命令</strong></p>
<ul>
<li><p>zadd key score member [score member …]：向有序集合添加一个或多个成员。</p>
<blockquote>
<p>如果某个member已经是有序集合的成员，那么更新这个member的score值，并通过重新插入这个member元素来保证该member在正确的位置上。</p>
<p>score值可以是整数值或双精度浮点数。</p>
</blockquote>
</li>
<li><p>zrange key start stop [WITHSCORES]：返回有序集中指定区间内的成员，其中成员的位置按分数值递增来排序，具有相同分数值的成员按字典序来排列。</p>
<blockquote>
<p>可以使用负数下标，以-1表示最后一个成员，-2表示倒数第二个成员，以此类推。</p>
<p>withscores：让成员和它的score值一并返回，返回列表以value1, score1, … valueN, scoreN的格式表示。</p>
</blockquote>
<p>zrevrange key start stop [WITHSCORES]：返回有序集中指定区间内的成员，其中成员的位置按分数值递减来排列，具有相同分数值的成员按字典序的逆序排列。</p>
</li>
<li><p>zrangebyscore key min max [WITHSCORES] [LIMIT offset count]：返回有序集合中指定分数区间（闭区间）的成员列表，按分数值递增排列，具有相同分数值的成员按字典序来排列。</p>
<blockquote>
<p>可选的LIMIT参数指定返回结果的数量及区间（类似于SQL中的SELECT LIMIT offset, count)。</p>
</blockquote>
<p>zrevrangebyscore key max min [WITHSCORES] [LIMIT offset count]：返回有序集中指定分数区间内的所有的成员，按分数值递减次序排列，具有相同分数值的成员按字典序的逆序排列。</p>
</li>
<li><p>zcard key：获取有序集合的成员数。</p>
</li>
<li><p>zcount key min max：计算有序集合中指定分数区间（闭区间）的成员数量。</p>
</li>
<li><p>zrank key member：返回有序集合中指定成员的索引（即排名，从0开始）。</p>
<p>zrevrank key member：返回有序集合中指定成员的索引，有序集成员按分数值递减排序。</p>
</li>
<li><p>zscore key member：返回有序集中成员的分数值。如果member元素不是有序集key的成员，或key不存在，返回nil。</p>
</li>
<li><p>zincrby key increment member：对有序集合中指定成员的分数加上增量increment。</p>
<blockquote>
<p>当key不存在，或member不是key的成员时，zincrby key increment member等同于zadd key increment member。</p>
</blockquote>
</li>
<li><p>zrem key member [member …]：移除有序集合中的一个或多个成员，不存在的成员将被忽略。</p>
<p>zremrangebyrank key start stop：移除有序集合中给定排名区间内（闭区间）的所有成员。</p>
<p>zremrangebyscore key min max：移除有序集合中给定分数区间内（闭区间）的所有成员。</p>
</li>
<li><p>zlexcount key min max：计算有序集合中指定字典区间内成员数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key1 0 a 0 b 0 c 0 d 0 e 0 f</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; zlexcount key1 - +</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; zlexcount key1 [b [f</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure>
</li>
<li><p>zrangebylex key min max [LIMIT offset count]：通过字典区间返回有序集合的成员。</p>
</li>
<li><p>zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</p>
<p>默认情况下，区间的取值使用闭区间（小于等于或大于等于），也可以通过给参数前增加<code>(</code>符号来使用可选的开区间（小于或大于）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zrangebyscore key (1 5</span><br><span class="line"><span class="comment"># 返回所有符合条件 1 &lt; score &lt;= 5 的成员</span></span><br><span class="line">zrangebyscore key (5 (10</span><br><span class="line"><span class="comment"># 返回所有符合条件 5 &lt; score &lt; 10 的成员</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>zremrangebylex key min max：移除有序集合中给定字典区间内的所有成员。</p>
</li>
<li><p>zinterstore destination numkeys key [key …]：计算给定的一个或多个有序集的交集，其中给定key的数量必须以numkeys参数指定，并将该交集（结果集）储存到destination中。</p>
<blockquote>
<p>默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和。</p>
</blockquote>
<p>zunionstore destination numkeys key [key …]：计算给定的一个或多个有序集的并集，其中给定key的数量必须以numkeys参数指定，并将该并集（结果集）储存到destination中。</p>
<blockquote>
<p>默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和 。</p>
</blockquote>
</li>
</ul>
<p><strong>数据结构</strong></p>
<p>zset是redis提供的一个非常特别的数据类型，其内部使用了2种数据结构：</p>
<ul>
<li><p>hash表</p>
<p>类似于java中的Map&lt;String, score&gt;，key为集合中的元素，value为元素对应的score，可以用来快速定位元素定义的score，时间复杂度为O(1)。</p>
</li>
<li><p>跳表</p>
<p>跳表（skiplist）是一个非常优秀的数据结构，实现简单，插入、删除、查找的复杂度均为O(logN)。</p>
<p>类似java中的ConcurrentSkipListSet，根据score的值排序后生成的一个跳表，可以快速按照位置的顺序或者score的顺序查询元素。</p>
</li>
</ul>
<p>跳表的原理：</p>
<p>首先从考虑一个有序表开始：</p>
<img src="image-20230818170155678.png" alt="image-20230818170155678" style="zoom:80%;" />

<p>从该有序表中搜索元素&lt;23, 43, 59&gt;，需要比较的次数分别为&lt;2, 4, 6&gt;，总共比较的次数为2 + 4 + 6 &#x3D; 12次。有没有优化的算法吗？链表是有序的，但不能使用二分查找。类似二叉搜索树，我们把一些节点提取出来，作为索引，得到如下结构：</p>
<img src="image-20230818170526594.png" alt="image-20230818170526594" style="zoom:80%;" />

<p>这里我们把&lt;14, 34, 50, 72&gt;提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。我们还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构：</p>
<img src="image-20230818170757637.png" alt="image-20230818170757637" style="zoom:80%;" />

<p>这里元素不多，体现不出优势，如果元素足够多，这种索引结构就能体现出优势来了。</p>
<h2 id="Redis新的3种数据类型"><a href="#Redis新的3种数据类型" class="headerlink" title="Redis新的3种数据类型"></a>Redis新的3种数据类型</h2><h3 id="Bitmaps：位操作字符串"><a href="#Bitmaps：位操作字符串" class="headerlink" title="Bitmaps：位操作字符串"></a>Bitmaps：位操作字符串</h3><p><strong>简介</strong></p>
<p>现代计算机使用二进制（位）作为信息的基本单位，1个字节等于8位，例如“abc”字符串是由3个字节组成，但实际在计算机内存储时将其使用二进制表示，“abc”分别对应的ASCII码是：97、98、99，对应的二进制分别是01100001、01100010、01100011，如下图：</p>
<img src="image-20240115101749689.png" alt="image-20240115101749689" style="zoom:80%;" />

<p>合理地使用位操作能够有效地提高内存使用率和开发效率。</p>
<p>Redis提供了Bitmaps这种“数据类型”来实现对位的操作：</p>
<ul>
<li>Bitmaps本身不是一种数据类型，实际上它就是字符串，但是它可以对字符串的位进行操作，字符串中每个字符对应1个字节，也就是8位，一个字符可以存储8个bit位信息。</li>
<li>Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫做偏移量。</li>
</ul>
<img src="image-20240115102333644.png" alt="image-20240115102333644" style="zoom:80%;" />



<p><strong>常用命令</strong></p>
<ul>
<li><p>setbit：设置某个偏移位的值（0或1）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置offset偏移位的值为value，offset的值从0开始，n代表第n+1个bit位。</p>
<p>offset参数必须大于或等于0，小于2^32（bit映射被限制在512MB之内）。</p>
<p>value的值只能为0或1。</p>
<p>返回值：指定偏移量原来储存的位。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit bit 100 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit bit 100</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit bit 101 <span class="comment"># bit默认被初始化为0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>每个独立用户是否访问过网站存放在bitmaps中，将访问的用户记做1，没有访问的用户记做0，用户id作为offset。</p>
<p>假设现在有20个用户，userid&#x3D;1, 6, 11, 15, 19的用户对网站进行了访问，那么当前bitmaps初始化结果如图：</p>
<img src="image-20240115103638120.png" alt="image-20240115103638120" style="zoom:80%;" />

<p>users:20220409这个bitmaps中表示2022-04-09这天独立访问的用户，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit <span class="built_in">users</span>:20220409 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit <span class="built_in">users</span>:20220409 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit <span class="built_in">users</span>:20220409 11 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit <span class="built_in">users</span>:20220409 15 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit <span class="built_in">users</span>:20220409 19 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>getbit：获取key所对应的bitmaps中offset偏移位的值，返回值为0或1。</p>
</li>
<li><p>bitcount：统计bit位都为1的数量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会进行统计，通过指定额外的start或者end参数，可以让计数只在特定的位上进行。</p>
<p>start和end参数，都可以使用负数值：比如-1表示最后一个位，而-2表示倒数第二个位，以此类推。</p>
<p>注意：start、end是指bit组字节的下标数，一个字节对应8个bit，所以[a, b]对应的offset范围是[8a, 8b+7]。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setbit user 7 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit user 15 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit user 23 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; bitcount user <span class="comment"># 获取user这个bitmaps中1的数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; bitcount user 0 1 <span class="comment"># 获取[0,1]这个字节内bit位上1的数量，也就是offset是[0,15]的位置上1的数量，所以结果为2</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; bitcount user 0 0 <span class="comment"># 获取[0,0]这个字节内bit位上1的数量，也就是offset是[0,7]的位置上1的数量，只有7这个位置，所以结果为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>bitop：对一个或多个bitmaps执行位操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bitop operation destkey key [key ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对一个或多个保存二进制位的字符串key进行位元操作，并将结果保存到destkey上。</p>
<p>operation可以是AND、OR、NOT、XOR这四种操作中的任意一种：</p>
<ul>
<li>AND：对一个或多个key求逻辑并，并将结果保存到destkey。</li>
<li>OR：对一个或多个key求逻辑或，并将结果保存到destkey。</li>
<li>XOR：对一个或多个key求逻辑异或，并将结果保存到destkey。</li>
<li>NOT：对给定key求逻辑非，并将结果保存到destkey。</li>
</ul>
<p>除了NOT操作之外，其他操作都可以接受一个或多个key作为输入。</p>
<p>返回值：保存到destkey的字符串长度和输入key中最长的字符串长度相等。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setbit bit-1 0 1 <span class="comment"># bit-1 = 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bit-1 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bit-2 0 1 <span class="comment"># bit-2 = 1011</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bit-2 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bit-2 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; bitop and and-result bit-1 bit-2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit and-result 0 <span class="comment"># and-result = 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit and-result 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit and-result 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit and-result 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>bitmaps与set比较</strong></p>
<p>假设网站有1亿用户，每天独立访问的用户有5千万，如果每天用集合类型和Bitmaps分别存储活跃用户，对比如下：</p>
<p>set和Bitmaps存储一天活跃用户对比：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>每个用户id占用空间</th>
<th>需要存储的用户量</th>
<th>全部内存量</th>
</tr>
</thead>
<tbody><tr>
<td>set集合</td>
<td>64位</td>
<td>50000000</td>
<td>64位 * 50000000 &#x3D; 400MB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位 * 100000000 &#x3D; 12.5MB</td>
</tr>
</tbody></table>
<p>很明显，这种情况下使用Bitmaps能节省很多的内存空间，尤其是随着时间推移节省的内存还是非常可观的。</p>
<p>set和Bitmaps存储独立用户空间对比：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>一天</th>
<th>一月</th>
<th>一年</th>
</tr>
</thead>
<tbody><tr>
<td>set集合</td>
<td>400MB</td>
<td>12GB</td>
<td>144GB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>12.5MB</td>
<td>375MB</td>
<td>4.5GB</td>
</tr>
</tbody></table>
<p>但Bitmaps并不是万金油，假如该网站每天的独立访问用户很少，例如只有10万（大量的僵尸用户），那么两者的对比如下表所示，很显然，这时候使用Bitmaps就不太合适了，因为大部分位都是0。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>每个用户id占用空间</th>
<th>需要存储的用户量</th>
<th>全部内存量</th>
</tr>
</thead>
<tbody><tr>
<td>set集合</td>
<td>64位</td>
<td>100000</td>
<td>64位 * 100000 &#x3D; 800KB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位 * 100000000 &#x3D; 12.5MB</td>
</tr>
</tbody></table>
<h3 id="HyperLoglog"><a href="#HyperLoglog" class="headerlink" title="HyperLoglog"></a>HyperLoglog</h3><p><strong>简介</strong></p>
<p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量），可以使用Redis的incr、incrby轻松实现。但像UV（UniqueVisitor独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>解决基数问题有很多种方案：</p>
<ul>
<li>数据存储在MySQL表中，使用distinct count计算不重复个数。</li>
<li>使用Redis提供的hash、set、bitmaps等数据结构来处理。</li>
</ul>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否降低一定的精度来平衡存储空间？Redis推出了HyperLogLog。</p>
<p>Redis HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在Redis里面，每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。</p>
<blockquote>
<p>什么是基数？</p>
<p>比如数据集{1, 3, 5, 7, 5, 7, 8}，这个数据集的基数集为{1, 3, 5 ,7, 8}，基数（不重复元素）个数为 5。基数估计就是在误差可接受的范围内，快速计算基数。</p>
</blockquote>
<p><strong>常用命令</strong></p>
<ul>
<li><p>pfadd：添加多个元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>向HyperLoglog类型的key中添加一个或者多个元素。<br>返回值：1表示添加成功，0表示添加失败。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfadd program java c c++ python <span class="comment"># 向program中添加4个元素java、c、c++、python，添加成功，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd program java <span class="comment"># 再次添加java，由于已经存在，所以添加失败，返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; pfadd program java js <span class="comment"># 再次添加2个元素，其中java已经存在，但js不存在，添加成功，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>pfcount：获取多个HLL合并后元素的个数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>统计一个或者多个key去重后元素的数量。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfadd uv1 a b c d e</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount uv1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; pfadd uv2 b c d e f</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount uv1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; pfcount uv1 uv2 <span class="comment"># uv1和uv2合并去重后为[a, b, c ,d, e, f]</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure>
</li>
<li><p>pfmerge：将多个HLL合并后元素放入另外一个HLL中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将多个sourcekey合并后放入destkey中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfmerge uv_dest uv1 uv2 <span class="comment"># 将uv1和uv2合并后放入uv_dest</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount uv_dest</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Geographic"><a href="#Geographic" class="headerlink" title="Geographic"></a>Geographic</h3><p><strong>简介</strong></p>
<p>Reids3.2中增加了对GEO类型的支持，GEO（Geographic），地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度，redis基于该类型，提供了经纬度设置、查询、范围查询、距离查询，经纬度Hash等常见操作。</p>
<p><strong>常用命令</strong></p>
<ul>
<li><p>geoadd：添加多个位置的经纬度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>longitude latitude member：经度 纬度 名称</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai <span class="comment"># 添加上海的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing <span class="comment"># 添加重庆、深圳、北京3个城市的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> china:city <span class="comment"># 发现geo实际上是使用zset类型存储的</span></span><br><span class="line">zset</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">3) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">4) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;4026042091628984&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;4046432193584628&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">6) <span class="string">&quot;4054803462927619&quot;</span></span><br><span class="line">7) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">8) <span class="string">&quot;4069885332386336&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>两级无法直接添加，一般会下载城市数据，直接通过java程序一次性导入。</p>
<p>有效的经度从-180度到180度，有效的纬度从-85.05112878度到85.05112878度。</p>
<p>当坐标位置超出指定范围时，该命令将会返回一个错误。</p>
<p>已经添加的数据，是无法再次往里面添加的。</p>
</blockquote>
</li>
<li><p>geopos：获取多个位置的坐标值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geopos key member [member ...]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city wuhan beijing chongqing <span class="comment"># 获取武汉、北京、重庆3个城市的坐标，由于没有添加武汉的数据，所以没有获取到</span></span><br><span class="line">1) (nil)</span><br><span class="line">2) 1) <span class="string">&quot;116.38000041246414185&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>geodist：获取两个位置的直线距离</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>unit指单位，包括m、km、ft、mi，对应于米、千米、英里、英尺，默认为米。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city beijing chongqing km <span class="comment"># 获取北京到重庆的直线距离</span></span><br><span class="line"><span class="string">&quot;1462.9505&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>georadius：以给定的经纬度为中心，找出某一半径内的元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">georadius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>单位：m、km、ft、mi，对应于米、千米、英里、英尺，默认为米。</p>
<p>WITHDIST：在返回元素的同时，将元素与中心之间的距离也一并返回。距离的单位和用户给定的范围单位保持一致。</p>
<p>WITHCOORD：将元素的经纬度一并返回。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km <span class="comment"># 对china:city进行检索，获取以经纬度(110, 30)为中心，半径为1000km内的位置列表</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;shenzhen&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p><strong>简介</strong></p>
<p>Redis发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。</p>
<p>Redis客户端可以订阅任意数量的频道。</p>
<p>下图展示了频道channel1，以及订阅这个频道的三个客户端client1、client2和client3之间的关系：</p>
<img src="image-20230822173148634.png" alt="image-20230822173148634" style="zoom: 80%;" />

<p>当有新消息通过publish命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端：</p>
<img src="image-20230603115322598.png" alt="image-20230603115322598" style="zoom:80%;" />



<p><strong>示例</strong></p>
<p>开启本地Redis服务，开启两个redis-cli客户端。</p>
<p>在第一个redis-cli客户端输入<code>subscribe chat1</code>，表示订阅chat1频道。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe chat1</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span> <span class="comment"># 返回值的类型：显示订阅成功</span></span><br><span class="line">2) <span class="string">&quot;chat1&quot;</span>     <span class="comment"># 订阅的频道名称</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1 <span class="comment"># 目前已订阅的频道数量</span></span><br></pre></td></tr></table></figure>

<p>在第二个redis-cli客户端输入<code>publish chat1 &quot;Hello&quot;</code>，表示向chat1频道发送消息，这个时候在第一个redis-cli客户端就能看到由第二个redis-cli客户端发送的测试消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish chat1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; publish chat1 <span class="string">&quot;How are you?&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅者的客户端会显示如下消息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 返回值的类型：信息</span></span><br><span class="line">2) <span class="string">&quot;chat1&quot;</span>   <span class="comment"># 来源：从哪个频道发送过来</span></span><br><span class="line">3) <span class="string">&quot;Hello&quot;</span>   <span class="comment"># 信息内容</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;chat1&quot;</span></span><br><span class="line">3) <span class="string">&quot;How are you?&quot;</span></span><br></pre></td></tr></table></figure>



<p><strong>常用命令</strong></p>
<ul>
<li><p>subscribe channel [channel …]：订阅一个或多个频道。</p>
</li>
<li><p>unsubscribe [channel [channel …]]：退订一个或多个频道。</p>
</li>
<li><p>publish channel message：将信息发送到指定的频道，返回接收到信息message的订阅者数量。</p>
</li>
<li><p>psubscribe pattern [pattern …]：订阅一个或多个符合给定模式的频道。</p>
<blockquote>
<p>每个模式以<code>*</code>作为匹配符，比如<code>it*</code>匹配所有以it开头的频道。</p>
</blockquote>
</li>
<li><p>punsubscribe [pattern [pattern …]]：退订所有给定模式的频道。</p>
</li>
</ul>
<h2 id="Jedis操作Redis"><a href="#Jedis操作Redis" class="headerlink" title="Jedis操作Redis"></a>Jedis操作Redis</h2><p>Jedis是java开发的操作redis的工具包，使用步骤如下：</p>
<ol>
<li><p>新建maven项目，导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisDemo</span> &#123;</span><br><span class="line">    Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;47.115.202.83&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试redis是否连通</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ping</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">        System.out.println(ping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  运行test1方法测试redis是否连通。</p>
<blockquote>
<p>注意：linux下安全组需要开放<code>6379</code>端口，并且防火墙也要允许该端口通过。</p>
<p>下方为运行过程中出现的错误：</p>
<ol>
<li><p>报错信息：&#x3D;&#x3D;redis.clients.jedis.exceptions.JedisDataException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients.&#x3D;&#x3D;</p>
<p>Redis .clients.jedis.exceptions. jedisdataexception: DENIED Redis运行在保护模式下，因为启用了保护模式，没有指定绑定地址，也没有向客户端请求认证密码。在这种模式下，只接受来自loopback接口的连接。如果你想从外部计算机连接到Redis，你可以采用以下解决方案之一：</p>
<ul>
<li>通过从服务器运行的同一主机连接到Redis，从loopback接口发送命令’CONFIG SET protected-mode no’来禁用保护模式，但是确保Redis不能从互联网公开访问，如果你这样做的话。使用CONFIG REWRITE使此更改永久生效。</li>
<li>或者你可以通过编辑Redis配置文件禁用保护模式，并将保护模式选项设置为“no”，然后重新启动服务器。</li>
<li>如果你手动启动服务器只是为了测试，用“——protected-mode no”选项重新启动它。</li>
<li>设置绑定地址或认证密码。注意:为了让服务器开始接受来自外部的连接，您只需要执行上述一项操作。</li>
</ul>
<p>注意：您只需执行上述操作之一，服务器就可以开始接受来自外部的连接。</p>
<p>解决方法：修改redis配置文件redis.conf，将<code>protected-mode yes</code>改为<code>protected-mode no</code>，并重启redis，注意启动时需要<code>指定配置文件</code>。</p>
<img src="image-20230818183649564.png" alt="image-20230818183649564"/>
</li>
<li><p>报错信息：&#x3D;&#x3D;redis.clients.jedis.exceptions.JedisConnectionException: Failed to connect to any host resolved for DNS name.&#x3D;&#x3D;</p>
<p>原因：redis的bing配置项存在问题。</p>
<p>解决方法：在配置文件redis.conf中找到bind配置项，将<code>bind 127.0.0.1</code>改为<code>bind 0.0.0.0</code>，前者表示只允许本机访问，后者表示所有电脑均可访问。修改后需要重启redis。</p>
<img src="image-20230818183757888.png" alt="image-20230818183757888"/></li>
</ol>
</blockquote>
</li>
<li><p>编写其他测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String类型测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stringTest</span><span class="params">()</span>&#123;</span><br><span class="line">    jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zs&quot;</span>);</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    System.out.println(jedis.ttl(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list类型测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listTest</span><span class="params">()</span>&#123;</span><br><span class="line">    jedis.rpush(<span class="string">&quot;courses&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;c++&quot;</span>, <span class="string">&quot;python&quot;</span>);</span><br><span class="line">    List&lt;String&gt; courses = jedis.lrange(<span class="string">&quot;courses&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String course : courses) &#123;</span><br><span class="line">        System.out.println(course);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set类型测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTest</span><span class="params">()</span>&#123;</span><br><span class="line">    jedis.sadd(<span class="string">&quot;users&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    Set&lt;String&gt; users = jedis.smembers(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash类型测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hashTest</span><span class="params">()</span>&#123;</span><br><span class="line">    jedis.hset(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;001&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;zs&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">    Map&lt;String, String&gt; user = jedis.hgetAll(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Zset类型测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">zsetTest</span><span class="params">()</span>&#123;</span><br><span class="line">    jedis.zadd(<span class="string">&quot;languages&quot;</span>, <span class="number">100</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">    jedis.zadd(<span class="string">&quot;languages&quot;</span>, <span class="number">80</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    jedis.zadd(<span class="string">&quot;languages&quot;</span>, <span class="number">70</span>, <span class="string">&quot;python&quot;</span>);</span><br><span class="line">    List&lt;String&gt; languages = jedis.zrange(<span class="string">&quot;languages&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    System.out.println(languages);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅消息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribeTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// subscribe(消息监听器, 频道列表)</span></span><br><span class="line">    jedis.subscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String channel, String message)</span> &#123;</span><br><span class="line">            System.out.println(channel + <span class="string">&quot;：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;chat1&quot;</span>);</span><br><span class="line">    TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布消息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishTest</span><span class="params">()</span>&#123;</span><br><span class="line">    jedis.publish(<span class="string">&quot;chat1&quot;</span>, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><ol>
<li><p>新建springboot项目，导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建配置文件application.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># redis服务器ip地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">47.115</span><span class="number">.202</span><span class="number">.83</span></span><br><span class="line">    <span class="comment"># redis服务器端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># redis密码</span></span><br><span class="line">    <span class="comment"># password: root</span></span><br><span class="line">    <span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">60000</span></span><br><span class="line">    <span class="comment"># redis默认情况下有16个分片，这里配置具体使用的分片，默认为0</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建控制器RedisController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// springboot中使用RedisTemplate来操作redis</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用下面5个对象来操作对应的类型</span></span><br><span class="line">redisTemplate.opsForValue(); <span class="comment">// 提供了操作string类型的所有方法</span></span><br><span class="line">redisTemplate.opsForList();  <span class="comment">// 提供了操作list类型的所有方法</span></span><br><span class="line">redisTemplate.opsForSet();   <span class="comment">// 提供了操作set的所有方法</span></span><br><span class="line">redisTemplate.opsForHash();  <span class="comment">// 提供了操作hash表的所有方法</span></span><br><span class="line">redisTemplate.opsForZSet();  <span class="comment">// 提供了操作zset的所有方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/stringTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">StringTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zs&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">listTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;courses&quot;</span>);</span><br><span class="line">        redisTemplate.opsForList().rightPushAll(<span class="string">&quot;courses&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;c++&quot;</span>, <span class="string">&quot;python&quot;</span>);</span><br><span class="line">        List&lt;String&gt; courses = redisTemplate.opsForList().range(<span class="string">&quot;courses&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> courses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/setTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">setTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        redisTemplate.opsForSet().add(<span class="string">&quot;users&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; users = redisTemplate.opsForSet().members(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hashTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hashTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        Map&lt;String , String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;001&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zs&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().putAll(<span class="string">&quot;user&quot;</span>, map);</span><br><span class="line">        Map&lt;Object, Object&gt; user = redisTemplate.opsForHash().entries(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/zsetTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">zsetTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;languages&quot;</span>);</span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;languages&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;languages&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;languages&quot;</span>, <span class="string">&quot;python&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        Set&lt;String&gt; languages = redisTemplate.opsForZSet().range(<span class="string">&quot;languages&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> languages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务介绍"><a href="#事务介绍" class="headerlink" title="事务介绍"></a>事务介绍</h3><p>Redis事务可以一次执行多个命令，并且带有以下三个重要保证：</p>
<ul>
<li>批量操作在发送exec命令前被放入队列缓存。</li>
<li>收到exec命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
<p>一个事务从开始到执行会经历三个阶段：开始事务、命令入队、执行事务。</p>
<p>以下是一个事务的例子，它先以<code>multi</code>开始一个事务，然后将多个命令入队到事务中，最后由<code>exec</code>命令触发事务，一并执行事务中的所有命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> book-name <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line">QUEUED <span class="comment"># 返回值为QUEUED，表示这个命令加入队列，但还没有被执行。</span></span><br><span class="line">127.0.0.1:6379&gt; get book-name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; sadd tag <span class="string">&quot;java&quot;</span> <span class="string">&quot;python&quot;</span> <span class="string">&quot;c++&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; smembers tag</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 3</span><br><span class="line">4) 1) <span class="string">&quot;java&quot;</span></span><br><span class="line">   2) <span class="string">&quot;c++&quot;</span></span><br><span class="line">   3) <span class="string">&quot;python&quot;</span></span><br></pre></td></tr></table></figure>

<p>单个Redis命令的执行是原子性的，但Redis没有在事务上增加任何维持原子性的机制，所以<code>Redis事务的执行并不是原子性的</code>。</p>
<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
<blockquote>
<p>官网说明：<a target="_blank" rel="noopener" href="https://redis.io/docs/manual/transactions/">https://redis.io/docs/manual/transactions/</a></p>
<p>It’s important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands.</p>
<p>译文：需要注意的是，即使一个命令失败，队列中的其他命令都会被处理——Redis不会停止对命令的处理。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby key1 2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">4) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul>
<li><p>multi：标记一个事务块的开始。</p>
</li>
<li><p>exec：执行所有事务块内的命令。</p>
<blockquote>
<p>假如某个（或某些）key正处于watch命令的监视之下，且事务块中有和这个（或这些）key相关的命令，那么exec命令只在这个（或这些）key没有被其他命令所改动的情况下执行并生效，否则该事务被打断（abort）。当操作被打断时，返回空值nil。</p>
</blockquote>
</li>
<li><p>discard：取消事务，放弃执行事务块内的所有命令。</p>
</li>
<li><p>watch key [key …]：监视一个（或多个）key，如果在事务执行之前这个（或这些）key被其他命令所改动，那么事务将被打断。</p>
<p>开启2个窗口，按照下表的时间点在不同的窗口执行对应的命令，观察结果。</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>窗口1</th>
<th>窗口2</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>flushdb</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td>set balance 100</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>watch balance</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td>multi</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td>set name zs</td>
<td>incrby balance 50</td>
</tr>
<tr>
<td>T6</td>
<td>incrby balance 10</td>
<td>get balance</td>
</tr>
<tr>
<td>T7</td>
<td>exec</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>get balance</td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>get name</td>
<td></td>
</tr>
</tbody></table>
<p>窗口1中对balance进行了监视，也就是说在执行watch balance命令之后，在exec命令之前，如果有其他请求对balance进行了修改，那么窗口1事务中所有的命令都会将会被取消执行。</p>
<p>窗口1watch balance后，由于T5时刻窗口2对balance进行了修改，导致窗口1中事务所有命令被取消执行。</p>
<p>窗口1执行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> balance 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch balance</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name zs</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby balance 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务，由于balance被窗口2修改了，所以本事务执行失败，返回nil</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get balance <span class="comment"># 获取balance，原始值为100，被窗口2加了50，结果为150</span></span><br><span class="line"><span class="string">&quot;150&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get name <span class="comment"># 获取name的值，事务中set name未成功，所以不存在name</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>窗口2执行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incrby balance 50</span><br><span class="line">(<span class="built_in">integer</span>) 150</span><br><span class="line">127.0.0.1:6379&gt; get balance</span><br><span class="line"><span class="string">&quot;150&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>unwatch：取消watch命令对所有key的监视。</p>
<blockquote>
<p>如果在执行WATCH命令之后， EXEC命令或DISCARD命令先被执行了的话，那么就不需要再执行UNWATCH了。</p>
<p>因为EXEC命令会执行事务，因此WATCH命令的效果已经产生了；而DISCARD命令在取消事务的同时也会取消所有对key的监视，因此这两个命令执行之后，就没有必要执行UNWATCH了。</p>
</blockquote>
</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><strong>入队阶段命令有误，导致所有命令取消执行</strong></p>
<p>入队阶段某个命令出现了错误报告，执行时整个队列中所有的命令都会被取消。</p>
<p>示例代码如下，事务中执行了3个set命令，而第3个命令set address本身存在问题，加入队列失败，最后执行exec的时候，所有的命令都被取消执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name zs</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> address <span class="comment"># 命令存在问题，导致加入队列失败</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;set&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 执行exec的时候，事务中所有命令都被取消</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>



<p><strong>入队中没有问题，执行中部分成功部分失败</strong></p>
<p>命令入队的过程没有问题，执行中出现了错误会导致部分成功部分失败。</p>
<p>示例代码如下，事务中有3个命令，3个命令都入队成功，执行exec命令时1和3命令成功，2命令失败。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr k1 <span class="comment"># k1的值递增1，但由于k1的值不是数字，执行失败</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">3) OK</span><br></pre></td></tr></table></figure>



<h3 id="事务冲突"><a href="#事务冲突" class="headerlink" title="事务冲突"></a>事务冲突</h3><p>想象一个场景：你的账户中只有10000，有多个人使用你的账户，同时去参加双十一抢购</p>
<ul>
<li>一个请求想给金额减8000</li>
<li>一个请求想给金额减5000</li>
<li>一个请求想给金额减1000</li>
</ul>
<img src="image-20240115104634691.png" alt="image-20240115104634691" style="zoom:80%;" />

<p>3个请求同时到来，看到的余额都是10000，大于操作金额，都去执行修改余额的操作，最后导致金额变成了-4000，这显然是有问题的。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><img src="image-20240115112016020.png" alt="image-20240115112016020" style="zoom:80%;" />

<p>悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人拿到这个数据就会block，直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在做操作之前先上锁。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><img src="image-20240115111833667.png" alt="image-20240115111833667" style="zoom:80%;" />

<p>乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在修改的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。redis就是使用这种check-and-set机制实现事务的。</p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis是一个基于内存的数据库，它的数据存放在内存中，内存有个问题就是关闭服务或者断电会丢失。</p>
<p>Redis的数据也支持写到硬盘中，这个过程就叫做持久化。Redis提供了2种不同形式的持久化方式：</p>
<ul>
<li>RDB（Redis DataBase）</li>
<li>AOF（Append Of File）</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p><strong>RDB是什么？</strong></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<p><strong>备份如何执行？</strong></p>
<p>Redis会单独创建（fork）一个子进程进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束后，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就是确保了极高的性能，如果需要进行大规模的恢复，且对数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
<p><strong>Fork</strong></p>
<p>Fork的作用是复制一个与当前进程一样的进程，新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，它是一个全新的进程，并作为原进程的子进程。</p>
<p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用。出于效率考虑，linux中引入了“写时复制技术”。</p>
<p>一般情况父进程和子进程会共用一段物理内存，只有进程空间的各段内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>
<p><strong>RDB持久化流程</strong></p>
<img src="image-20230819080858365.png" alt="image-20230819080858365" style="zoom: 67%;" />



<p><strong>指定备份文件的名称</strong></p>
<p>在redis.conf中，可以修改RDB备份文件的名称，默认为dump.rdb，如下：</p>
<img src="image-20230819081747422.png" alt="image-20230819081747422"/>



<p><strong>指定备份文件存放的目录</strong></p>
<p>在redis.conf中，RDB文件的保存目录是可以修改的，默认为Redis启动命令所在的目录，如下：</p>
<img src="image-20230819081621272.png" alt="image-20230819081621272"/>



<p><strong>触发RDB备份</strong></p>
<ol>
<li><p>自动备份，需配置备份规则</p>
<p>可在redis.conf中配置自动备份的规则，默认规则如下：</p>
<img src="image-20230819101137303.png" alt="image-20230819101137303"/>

<p>save用来配置备份的规则，格式：<code>save 秒钟 写操作次数</code>。默认为1分钟内修改了1万次，或5分钟内修改了10次，或15分钟内修改了1次。</p>
<p>示例：设置20秒内最少有3次key发生变化，则进行备份。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 20 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动执行命令备份</p>
<p>有2个命令可以触发备份：</p>
<ul>
<li>save：只管保存，其他不管，全部阻塞，手动保存，不建议使用。</li>
<li>bgsave：redis会在后台异步进行快照操作，快照同时还可以响应客户端情况。</li>
</ul>
<blockquote>
<p>可以通过<code>lastsave</code>命令获取最后一次成功生成快照的时间。</p>
</blockquote>
</li>
<li><p>flushall命令</p>
<p>执行flushall命令也会产生dump.rdb文件，但里面是空的，无意义。</p>
</li>
</ol>
<p><strong>redis.conf其他一些配置</strong></p>
<ul>
<li><p>stop-writes-on-bgsave-error：当磁盘满时是否关闭redis的写操作</p>
<blockquote>
<p>stop-writes-on-bgsave-error用来指定当redis无法写入磁盘的话，是否直接关掉redis的写操作，推荐yes。</p>
</blockquote>
<img src="image-20230819101809204.png" alt="image-20230819101809204"/>
</li>
<li><p>rdbcompression：rdb备份是否开启压缩</p>
<blockquote>
<p>对于存储到磁盘中的rdb快照文件，可以设置是否进行压缩，如果是的话，redis会采用LZF算法进行压缩。</p>
<p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，推荐yes。</p>
</blockquote>
<img src="image-20230819101949180.png" alt="image-20230819101949180"/>
</li>
<li><p>rdbchecksum：是否检查rdb备份文件的完整性</p>
<blockquote>
<p>存储快照后还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取最大的性能提升，可以关闭此功能。推荐yes。</p>
</blockquote>
<img src="image-20230819102116498.png" alt="image-20230819102116498"/></li>
</ul>
<p><strong>RDB的备份和恢复</strong></p>
<p>先通过config get dir查询rdb文件的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get <span class="built_in">dir</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/home/llc/redis-6.0.8/src&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后将rdb的备份文件*.rdb文件拷贝到别的地方</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> dump.rdb dump2.rdb</span><br></pre></td></tr></table></figure>

<p>rdb的恢复</p>
<ul>
<li>关闭redis</li>
<li>先把备份的文件拷贝到工作目录cp dump2.rdb dump.rdb</li>
<li>启动redis，备份数据直接加载，数据被恢复</li>
</ul>
<p><strong>优势</strong></p>
<ul>
<li>适合大规模数据恢复</li>
<li>对数据完整性和一致性要求不高更适合使用</li>
<li>节省磁盘空间</li>
<li>恢复速度快</li>
</ul>
<img src="image-20230819103122856.png" alt="image-20230819103122856" style="zoom:80%;" />



<p><strong>劣势</strong></p>
<ul>
<li>Fork的时候内存中的数据会被克隆一份，大致2倍的膨胀，需要考虑</li>
<li>虽然Redis在fork的时候使用了写时拷贝技术，但是如果数据庞大时还是比较消耗性能</li>
<li>在备份周期内一定间隔时间做一次备份，否则如果Redis意外宕机，就会丢失最后一次快照后所有修改</li>
</ul>
<p><strong>如何停止RDB？</strong></p>
<p>动态停止RDB：<code>redis-cli config set save &quot;&quot;</code>。save后给空值表示禁用保存策略。</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><strong>AOF是什么？</strong></p>
<p>以日志的形式来记录每个写操作（增量保存），将redis执行过的所有写指令记录下来（读操作不记录），只允追加文件但不可改写文件，redis启动之初会读取该文件重新构造数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p><strong>AOF持久化流程</strong></p>
<ul>
<li>客户端的请求写命令会被追加（append）到AOF缓冲区内</li>
<li>AOF缓冲区会根据AOF持久化策略[always, everysec, no]将操作同步（sync）到磁盘的AOF文件中</li>
<li>AOF文件大小超过重写策略或手动重写时，会对AOF文件进行重写（rewrite），压缩AOF文件容量</li>
<li>redis服务器重启时，会重新加载（load）AOF文件中的写操作达到数据恢复的目的</li>
</ul>
<img src="image-20230819104459504.png" alt="image-20230819104459504" style="zoom:80%;" />



<p><strong>AOF默认不开启</strong></p>
<p>可以在redis.conf文件中对AOF进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly no # 是否开启AOF，yes：开启，no：不开启，默认为no</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # aof文件名称，默认为appendonly.aof</span><br><span class="line">dir ./ # aof文件所在目录，默认./，表示执行启动命令时所在的目录</span><br><span class="line"># 比如我们在/opt目录中，去执行redis-server /etc/redis.conf来启动redis，那么dir此时就是/opt目录</span><br></pre></td></tr></table></figure>



<p><strong>AOF和RDB同时开启，redis听谁的？</strong></p>
<p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p>
<p><strong>AOF启动&#x2F;修复&#x2F;恢复</strong></p>
<p>AOF的备份机制和性能虽然和RDB不同，但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p>
<p>正常恢复</p>
<ul>
<li>修改默认的appendonly no，改为yes</li>
<li>将有数据的aof文件复制一份保存到对应的目录（查看目录：<code>config get dir</code>）</li>
<li>恢复：重启redis然后重新加载</li>
</ul>
<p>异常恢复</p>
<ul>
<li>修改默认的appendonly no，改为yes</li>
<li>如遇到aof文件损坏，通过<code>/usr/local/bin/redis-check-aof --fix appendonly.aof</code>进行恢复</li>
</ul>
<p><strong>AOF同步频率设置</strong></p>
<p>可以在redis.config中配置AOF同步的频率</p>
<img src="image-20230819105357855.png" alt="image-20230819105357855"/>

<ul>
<li><p>appendfsync always：每次写入立即同步</p>
<p>始终同步，每次redis的写入都会立刻记入日志；性能较差但数据完整性比较好。</p>
</li>
<li><p>appendfsync everysec：每秒同步</p>
<p>每秒同步，每秒记录日志一次，如果宕机，本秒数据可能丢失；更新的命令会放在内存中AOF缓冲区，每秒将缓冲区的命令追加到AOF文件</p>
</li>
<li><p>appendfsync no：不主动同步</p>
<p>redis不主动进行同步，把同步交给操作系统。</p>
</li>
</ul>
<p><strong>rewrite压缩（AOF文件压缩）</strong></p>
<ul>
<li><p>rewrite压缩是什么？</p>
<p>AOF采用文件追加方式，文件会越来越大，为了避免出现此情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof触发重写。</p>
</li>
<li><p>重写原理，如何实现重写？</p>
<p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件，最后在rename替换旧文件），redis4.0版本后的重写，是指就把rdb的快照，以二进制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p>
</li>
<li><p>触发机制，何时重写？</p>
<ul>
<li><p>bgrewriteaof：手动触发重写</p>
<p>从Redis 2.4开始， AOF重写由Redis自行触发，bgrewriteaof仅仅用于手动触发重写操作。</p>
<p>redis会记录上次重写的aof大小，默认配置是当aof文件大小是上次rewrite后大小的2倍且文件大于64M时触发。</p>
<p>重写虽然可以节约大量磁盘空间，减少恢复时间，但是每次重写还是有一定负担的，因此设置redis满足一定条件才会进行重写。</p>
</li>
<li><p>auto-aof-rewrite-percentage：设置重写基准值</p>
<p>设置重写的基准值，默认100，当文件达到100%时开始重写（文件是原来重写后文件的2倍时重写）。</p>
</li>
<li><p>auto-aof-rewrite-min-size：设置重写基准值</p>
<p>设置重写的基准值，默认64MB，AOF文件大小超过这个值开始重写。</p>
</li>
</ul>
<p>举个例子：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？ &#x3D;&gt; 100MB</p>
<p>系统载入时或者上次重写完毕时，redis会记录此时AOF大小，设置base_size。</p>
<p>如果Redis的AOF当前大小 &gt;&#x3D; base_size + base_size * 100%（auto-aof-rewrite-percentage默认值）且当前大小 &gt;&#x3D; 64mb（auto-aof-rewrite-min-size默认值）的情况下，redis会对AOF进行重写。</p>
</li>
<li><p>重写流程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bgrewriteaof</span><br><span class="line">Background append only file rewriting started</span><br></pre></td></tr></table></figure>

<ul>
<li>手动执行bgrewriteaof命令触发重写，判断是否当前有bgfsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</li>
<li>主进程fork出子进程执行重写操作，保证主进程不会阻塞。</li>
<li>子进程遍历redis内存中的数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整性以及新AOF文件生成期间的新的数据修改动作不会丢失。</li>
<li>子进程写完新的AOF文件后，向主进程发送信号，父进程更新统计信息。</li>
<li>主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</li>
<li>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</li>
</ul>
<img src="image-20230819110314008.png" alt="image-20230819110314008"/>
</li>
<li><p>no-appendfsync-on-rewrite：重写时，不会执行appendfsync操作</p>
<p>该参数表示在正在进行AOF重写时不会将AOF缓冲区中的数据同步到旧的AOF文件磁盘，也就是说在进行AOF重写的时候，如果此时有写操作进来，此时写操作的命令会放在aof_buf缓存中（内存中），而不会将其追加到旧的AOF文件中，这么做是为了避免同时写旧的AOF文件和新的AOF文件对磁盘产生的压力。</p>
<p>默认是ON，表示关闭，即在AOF重写时，会对AOF缓冲区中的数据做同步磁盘操作，这在很大程度上保证了数据的安全性。</p>
<p>但在数据量很大的场景，因为两者都会消耗磁盘IO，对磁盘的影响较大，可以将其设置为“yes”减轻磁盘压力，但在极端情况下可能丢失整个AOF重写期间的数据。</p>
<p>如果no-appendfsync-on-rewrite为yes，不写入aof文件，只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p>
<p>如果no-appendfsync-on-rewrite为no，还是会把数据库往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p>
</li>
</ul>
<p><strong>优势</strong></p>
<ul>
<li>备份机制更稳健，丢失数据概率更低</li>
<li>可读的日志文本，通过操作AOF文件，可以处理误操作</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>比RDB占用更多的磁盘空间</li>
<li>恢复备份速度要慢</li>
<li>每次读写都同步的话，有一定的性能压力</li>
<li>存在个别bug，造成不能恢复</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>AOF文件是一个只进行追加的日志文件</li>
<li>Redis可以在AOF文件体积变得过大时，自动地在后台对AOF文件进行重写</li>
<li>AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以redis协议的格式保存，因此AOF文件的内容非常容易被人读懂，对文件进行分析也很轻松。</li>
<li>对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积</li>
<li>根据所使用的fsync策略，AOF的速度可能会慢于RDB</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>使用建议</strong></p>
<p>官方推荐2个都启用。如果对数据不敏感，可以单独用RDB。不建议单独使用AOF，因为可能会出现BUG。如果只是做纯内存缓存，可以都不用。</p>
<p><strong>官网建议</strong></p>
<ul>
<li><p>RDB持久化方式能够在指定的时间间隔对数据进行快照存储</p>
</li>
<li><p>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始数据，AOF命令以redis协议追加保存每次写的操作到AOF文件末尾</p>
</li>
<li><p>Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</p>
</li>
<li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式</p>
</li>
<li><p>同时开启两种持久化方式</p>
<p>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整</p>
</li>
<li><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要只是用AOF呢？</p>
<p>建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段</p>
</li>
<li><p>性能建议</p>
<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留<code>save 900 1</code>这一条</li>
<li>如果使用AOF，好处是在最恶劣的情况下也只会丢失不超过两秒数据，启动脚本较简单，只load自己的AOF文件就可以了</li>
<li>AOF的代价，一是带来持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据（aof_rewrite_buf）写到文件造成的阻塞几乎是不可避免的</li>
<li>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基数大小默认值64M（autoaof-rewrite-min-size）太小了，可以设置到5G以上</li>
<li>默认超过原大小100%（auto-aof-rewrite-percentage）大小时重写可以改到适当的数值。</li>
</ul>
</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>主机更新后根据配置和策略，自动同步到备机的master&#x2F;slave机制，Master以写为主，Slave以读为主。</p>
<p>作用：</p>
<ul>
<li>读写分离，性能扩展，降低主服务器的压力；</li>
<li>容灾，快速恢复，主机挂掉时从机变为主机。</li>
</ul>
<img src="image-20230819123958901.png" alt="image-20230819123958901" style="zoom: 67%;" />



<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>下面我们来配置1主2从的效果，现实中是需要3台机器的，为了方便，我们就在一台机器上进行演示，通过不同的端口来区分机器，3台机器的配置如下：</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>master（主）</td>
<td>6379</td>
</tr>
<tr>
<td>slave1（从）</td>
<td>6380</td>
</tr>
<tr>
<td>slave2（从）</td>
<td>6381</td>
</tr>
</tbody></table>
<img src="image-20230819124142747.png" alt="image-20230819124142747" style="zoom: 67%;" />

<p><strong>配置主从</strong></p>
<ol>
<li><p>创建案例工作目录：master-slave</p>
<p>执行下面命令创建&#x2F;llc&#x2F;master-slave目录，本次所有操作均在master-slave目录进行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /home/llc/master-slave</span><br><span class="line"><span class="built_in">cd</span> /home/llc/master-slave/</span><br></pre></td></tr></table></figure>
</li>
<li><p>将redis.conf复制到master-slave目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /home/llc/redis-6.0.8/redis.conf /home/llc/master-slave/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建master的配置文件：redis-6379.conf</p>
<p>在&#x2F;home&#x2F;llc&#x2F;master-slave目录下创建redis-6379.conf文件，内容如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis.conf是redis原配置文件，内部包含了很多默认的配置，这里使用include将其引用，相当于把redis.conf内容直接贴进来了</span><br><span class="line">include /home/llc/master-slave/redis.conf</span><br><span class="line">daemonize yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 配置密码</span><br><span class="line">requirepass 123456</span><br><span class="line">dir /home/llc/master-slave/</span><br><span class="line">logfile /home/llc/master-slave/6379.log</span><br><span class="line"></span><br><span class="line"># 端口</span><br><span class="line">port 6379</span><br><span class="line"># rdb文件</span><br><span class="line">dbfilename dump_6379.rdb</span><br><span class="line"># pid文件</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br></pre></td></tr></table></figure>

</li>
<li><p>创建slave1的配置文件：redis-6380.conf，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis.conf是redis原配置文件，内部包含了很多默认的配置，这里使用include将其引用，相当于把redis.conf内容直接贴进来了</span><br><span class="line">include /home/llc/master-slave/redis.conf</span><br><span class="line">daemonize yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 配置密码</span><br><span class="line">requirepass 123456</span><br><span class="line">dir /home/llc/master-slave/</span><br><span class="line">logfile /home/llc/master-slave/6380.log</span><br><span class="line"></span><br><span class="line"># 端口</span><br><span class="line">port 6380</span><br><span class="line"># rdb文件</span><br><span class="line">dbfilename dump_6380.rdb</span><br><span class="line"># pid文件</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line"></span><br><span class="line"># 用来指定主机：slaveof 主机ip 端口</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"># 主机的密码</span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建slave2的配置文件：redis-6381.conf，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis.conf是redis原配置文件，内部包含了很多默认的配置，这里使用include将其引用，相当于把redis.conf内容直接贴进来了</span><br><span class="line">include /home/llc/master-slave/redis.conf</span><br><span class="line">daemonize yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 配置密码</span><br><span class="line">requirepass 123456</span><br><span class="line">dir /home/llc/master-slave/</span><br><span class="line">logfile /home/llc/master-slave/6381.log</span><br><span class="line"></span><br><span class="line"># 端口</span><br><span class="line">port 6381</span><br><span class="line"># rdb文件</span><br><span class="line">dbfilename dump_6381.rdb</span><br><span class="line"># pid文件</span><br><span class="line">pidfile /var/run/redis_6381.pid</span><br><span class="line"></span><br><span class="line"># 用来指定主机：slaveof 主机ip 端口</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"># 主机的密码</span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动master、slave1、slave2，并检查是否启动成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/llc/redis-6.0.8/src/</span><br><span class="line">./redis-server /home/llc/master-slave/redis-6379.conf</span><br><span class="line">./redis-server /home/llc/master-slave/redis-6380.conf</span><br><span class="line">./redis-server /home/llc/master-slave/redis-6381.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程，检查是否启动成功</span></span><br><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<img src="image-20230819135308002.png" alt="image-20230819135308002"/>
</li>
<li><p>查看主机信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过redis-cli命令连接主机</span></span><br><span class="line">./redis-cli -p 6379 -a 123456</span><br><span class="line"><span class="comment"># 查看主从信息</span></span><br><span class="line">info Replication</span><br><span class="line"></span><br><span class="line">[root@iZf8zde65mian5izoh0918Z src]<span class="comment"># ./redis-cli -p 6379 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">&#x27;-a&#x27;</span> or <span class="string">&#x27;-u&#x27;</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">127.0.0.1:6379&gt; info Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 当前角色，master表示主机</span></span><br><span class="line">connected_slaves:2 <span class="comment"># 2表示有2台从机，下面2行为从机信息（包括ip、端口等信息）</span></span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=154,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=154,lag=1</span><br><span class="line">master_replid:d98c4e0e14813e1e9e7d43eddb98cccf8915a907</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:154</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:154</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看slave1信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZf8zde65mian5izoh0918Z src]<span class="comment"># ./redis-cli -p 6380 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">&#x27;-a&#x27;</span> or <span class="string">&#x27;-u&#x27;</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">127.0.0.1:6380&gt; info Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave <span class="comment"># 当前角色，slave表示从机</span></span><br><span class="line">master_host:127.0.0.1 <span class="comment"># 主机ip</span></span><br><span class="line">master_port:6379 <span class="comment"># 主机端口</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:7</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:448</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:d98c4e0e14813e1e9e7d43eddb98cccf8915a907</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:448</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:448</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看slave2信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZf8zde65mian5izoh0918Z src]<span class="comment"># ./redis-cli -p 6381 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">&#x27;-a&#x27;</span> or <span class="string">&#x27;-u&#x27;</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">127.0.0.1:6381&gt; info Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:8</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:602</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:d98c4e0e14813e1e9e7d43eddb98cccf8915a907</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:602</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:602</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证主从同步效果</p>
<p>在master上面执行下方命令：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name zs</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>在slave1上执行下方命令，可以看出数据已经同步过来了。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; mget name age</span><br><span class="line">1) <span class="string">&quot;zs&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br></pre></td></tr></table></figure>

<p>同样到slave2上也执行一下，效果如下：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; mget name age</span><br><span class="line">1) <span class="string">&quot;zs&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p>slave启动成功连接到master后，会给master发送数据同步消息（发送sync命令）。master接收到slave发来的数据同步消息后，把主服务器的数据进行持久化到rdb文件，同时会收集接收到的用于修改数据的命令，master将rdb文件发送给slave，完成一次完全同步。</p>
<p>全量复制：slave服务在接收到master发来的rdb文件后，将其存盘并加载到内存。</p>
<p>增量复制：master继续将收集到的修改命令依次传给slave，完成同步。</p>
<blockquote>
<p>只要重新连接master，一次完全同步（全量复制）将会被自动执行。</p>
</blockquote>
<img src="image-20230819145656248.png" alt="image-20230819145656248" style="zoom:80%;" />

<blockquote>
<ul>
<li><p>主redis挂掉以后情况会如何？从机是上位还是原地待命？</p>
<p>主机挂掉后，从机会待命，小弟还是小弟，会等着大哥恢复，不会篡位。</p>
</li>
<li><p>从挂掉后又恢复了，会继续从主同步数据么？</p>
<p>会的，当从重启之后，会继续将中间缺失的数据同步过来。</p>
</li>
</ul>
</blockquote>
<h3 id="常用的主从结构"><a href="#常用的主从结构" class="headerlink" title="常用的主从结构"></a>常用的主从结构</h3><h4 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h4><p>上方案例演示的就是一主二从，不过采用的都是配置文件的方式，实际上从机可以采用命令的方式配置。</p>
<ol>
<li><p>创建案例工作目录：master-slave</p>
</li>
<li><p>将redis.conf复制到master-slave目录</p>
</li>
<li><p>创建master的配置文件：redis-6379.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis.conf是redis原配置文件，内部包含了很多默认的配置，这里使用include将其引用，相当于把redis.conf内容直接贴进来了</span></span><br><span class="line">include /home/llc/master-slave/redis.conf</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置密码</span></span><br><span class="line">requirepass 123456</span><br><span class="line"><span class="built_in">dir</span> /home/llc/master-slave/</span><br><span class="line">logfile /home/llc/master-slave/6379.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># rdb文件</span></span><br><span class="line">dbfilename dump_6379.rdb</span><br><span class="line"><span class="comment"># pid文件</span></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建slave1的配置文件：redis-6380.conf（配置同redis-6379，修改对应端口号为6380）</p>
</li>
<li><p>创建slave2的配置文件：redis-6381.conf（配置同redis-6379，修改对应端口号为6381）</p>
</li>
<li><p>启动master、slave1、slave2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/llc/redis-6.0.8/src/</span><br><span class="line">./redis-server /home/llc/master-slave/redis-6379.conf</span><br><span class="line">./redis-server /home/llc/master-slave/redis-6380.conf</span><br><span class="line">./redis-server /home/llc/master-slave/redis-6381.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别连接3台机器，查看各自主从信息</p>
<p>本次我们并没有在slave1和slave2的配置文件通过slaveof命令配置主从信息，所以目前3台机器的角色都是master。</p>
<p>分别连接3个redis，然后用info replication命令看下3个的主从信息，如下：</p>
<img src="image-20230819173804127.png" alt="image-20230819173804127"/>

<img src="image-20230819173845403.png" alt="image-20230819173845403"/>

<img src="image-20230819173946905.png" alt="image-20230819173946905"/>

<p>可以发现三者的角色均为master。</p>
<p>下面我们将通过控制台命令来指定slave1和slave2的为master的从库。</p>
</li>
<li><p>配置slave1为master的从库</p>
<p>执行下面命令，连接slave1</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -p 6380 -a 123456</span><br></pre></td></tr></table></figure>

<p>执行下面命令，设置master的密码（由于master需要密码，所以在slave1中需要指定master的密码，否则无法同步数据。）</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config <span class="built_in">set</span> masterauth 123456</span><br></pre></td></tr></table></figure>

<p>执行下面命令，指定slave1作为master的从机</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>使用info replication命令查看下slave1的主从信息</p>
<img src="image-20230819174404788.png" alt="image-20230819174404788"/>
</li>
<li><p>配置slave2为master的从库</p>
<p>执行下面命令，连接slave2</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -p 6381 -a 123456</span><br></pre></td></tr></table></figure>

<p>剩余操作同上，结果如下：</p>
<img src="image-20230819174706539.png" alt="image-20230819174706539"/>
</li>
<li><p>查看master的主从信息</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -p 6379 -a 123456</span><br><span class="line">info replication</span><br></pre></td></tr></table></figure>

<img src="image-20230819174901641.png" alt="image-20230819174901641"/>

<blockquote>
<p>注意：</p>
<ul>
<li>通过slaveof命令指定主从的方式，slave重启之后主从配置会失效，所以重启后需要在slave上重新通过slaveof命令进行设置。</li>
<li>中途通过slaveof变更转向，本地的数据会被清除，会从新的master重新同步数据。</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h4><p>若master下面挂很多slave，master会有压力，实际上slave下面也可以挂slave，如下图，配置这里就不演示了，和上面的类似。</p>
<img src="image-20230819175407087.png" alt="image-20230819175407087" style="zoom:80%;" />



<h4 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h4><p>当master挂掉之后，我们可以从slave中选择一个作为主机。比如我们想让slave1作为主机，那么可以在slave1上执行下方命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>

<p>此时slave1就变成主机了，然后再去其他slave上面执行slaveof命令将其挂在slave1上。</p>
<p>这种主备切换有个缺点：需要以手动执行命令的方式进行操作，不太方便。</p>
<p>下面来介绍另外一种方式：哨兵模式，master挂掉之后，自动从slave中选择一个作为主机，自动实现故障转移。</p>
<h3 id="哨兵（Sentinel）模式"><a href="#哨兵（Sentinel）模式" class="headerlink" title="哨兵（Sentinel）模式"></a>哨兵（Sentinel）模式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>什么是哨兵模式？</strong></p>
<p>反客为主的自动版，能够自动监控master是否发生故障，如果故障了会根据投票数从slave中挑选一个作为master，其他的slave会自动转向同步新的master，实现故障自动转义。</p>
<p><strong>原理</strong></p>
<p>sentinel会按照指定的频率给master发送ping请求，看看master是否还活着，若master在指定时间内未正常响应sentinel发送的ping请求，sentinel则认为master挂掉了，但是这种情况存在误判的可能，比如：可能master并没有挂，只是sentinel和master之间的网络不通导致，导致ping失败。</p>
<p>为了避免误判，通常会启动多个sentinel，一般是奇数个，比如3个，那么可以指定当有多个sentinel都觉得master挂掉了，此时才断定master真的挂掉了，通常这个值设置为sentinel的一半，比如sentinel的数量是3个，那么这个量就可以设置为2个。</p>
<p>当多个sentinel经过判定，断定master确实挂掉了，接下来sentinel会进行故障转移：会从slave中投票选出一个服务器，将其升级为新的主服务器，并让失效主服务器的其他从服务器slaveof指向新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。</p>
<p><strong>更多sentinel介绍</strong></p>
<p>关于sentinel的更多信息，详见：<a target="_blank" rel="noopener" href="http://itsoku.com/article/247">http://itsoku.com/article/247</a></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>案例：配置1主2从3个哨兵</strong></p>
<p>下面我们来实现1主2从3个sentinel的配置，当从的挂掉之后，要求最少有2个sentinel认为主的挂掉了，才进行故障转移。</p>
<p>为了方便，我们在一台机器上进行模拟，通过端口来区分6个不同的节点（1个master、2个slave、3个sentinel），节点配置信息如下：</p>
<img src="image-20230819194551057.png" alt="image-20230819194551057" style="zoom:80%;" />

<ol>
<li><p>创建案例工作目录：sentinel</p>
<p>执行下面命令创建&#x2F;home&#x2F;llc&#x2F;sentinel目录，本次所有操作，均在sentinel目录下进行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /home/llc/sentinel</span><br><span class="line"><span class="built_in">cd</span> /home/llc/sentinel</span><br></pre></td></tr></table></figure>
</li>
<li><p>将redis.conf复制到sentinel目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /home/llc/redis-6.0.8/redis.conf /home/llc/sentinel/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建master的配置文件：redis-6379.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis.conf是redis原配置文件，内部包含了很多默认的配置，这里使用include将其引用，相当于把redis.conf内容直接贴进来了</span><br><span class="line">include /home/llc/sentinel/redis.conf</span><br><span class="line">daemonize yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">dir /home/llc/sentinel/</span><br><span class="line">logfile /home/llc/sentinel/6379.log</span><br><span class="line"></span><br><span class="line"># 端口</span><br><span class="line">port 6379</span><br><span class="line"># rdb文件</span><br><span class="line">dbfilename dump_6379.rdb</span><br><span class="line"># pid文件</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建slave1的配置文件：redis-6380.conf（配置同redis-6379，修改对应端口号为6380）</p>
</li>
<li><p>创建slave2的配置文件：redis-6381.conf（配置同redis-6379，修改对应端口号为6381）</p>
</li>
<li><p>启动master、slave1、slave2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/llc/redis-6.0.8/src/</span><br><span class="line">./redis-server /home/llc/sentinel/redis-6379.conf</span><br><span class="line">./redis-server /home/llc/sentinel/redis-6380.conf</span><br><span class="line">./redis-server /home/llc/sentinel/redis-6381.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置slave1为master的从库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -p 6380</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">info replication</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置slave2为master的从库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -p 6381</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">info replication</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证主从复制是否正常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -p 6379</span><br><span class="line">info replication</span><br></pre></td></tr></table></figure>

<img src="image-20230819200746421.png" alt="image-20230819200746421"/>

<p>在master中执行下面命令，写入数据</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flushdb</span><br><span class="line"><span class="built_in">set</span> name jack</span><br></pre></td></tr></table></figure>

<p>查看slave1和slave2中name的值，若数据一致，则说明同步正常。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get name</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建sentinel1的配置文件：sentinel-26379.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置文件目录</span></span><br><span class="line"><span class="built_in">dir</span> /home/llc/sentinel/</span><br><span class="line"><span class="comment"># 日志文件位置</span></span><br><span class="line">logfile <span class="string">&quot;./sentinel-26379.log&quot;</span></span><br><span class="line"><span class="comment"># pid文件</span></span><br><span class="line">pidfile /var/run/sentinel_26379.pid</span><br><span class="line"><span class="comment"># 是否后台运行</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment"># 监控主服务器master的名字：mymaster，IP：127.0.0.1，port：6379，最后的数字2表示当Sentinel集群中有2个Sentinel认为master存在故障不可用，则进行自动故障转移</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="comment"># master响应超时时间（毫秒），Sentinel会向master发送ping来确认master，如果在60秒内，ping不通master，则主观认为master不可用</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line"><span class="comment"># 故障转移超时时间（毫秒），如果3分钟内没有完成故障转移操作，则视为转移失败</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"><span class="comment"># 故障转移之后，进行新的主从复制，配置项指定了最多有多少个slave对新的master进行同步，那可以理解为1是串行复制，大于1是并行复制</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="comment"># 指定mymaster主的密码（没有就不指定）</span></span><br><span class="line"><span class="comment"># sentinel auth-pass mymaster 123456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建sentinel2的配置文件：sentinel-26380.conf（配置同sentinel-26379，修改对应端口号为26380）</p>
</li>
<li><p>创建sentinel3的配置文件：sentinel-26381.conf（配置同sentinel-26379，修改对应端口号为26381）</p>
</li>
<li><p>启动3个sentinel</p>
<p>启动sentinel有2种方式：</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">redis-server sentinel.conf --sentinel</span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure>

<p>使用方式二启动3个sentinel</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/llc/redis-6.0.8/src</span><br><span class="line">./redis-sentinel /home/llc/sentinel/sentinel-26379.conf</span><br><span class="line">./redis-sentinel /home/llc/sentinel/sentinel-26380.conf</span><br><span class="line">./redis-sentinel /home/llc/sentinel/sentinel-26381.conf</span><br></pre></td></tr></table></figure>

</li>
<li><p>分别查看3个sentinel的信息</p>
<p>分别对3个sentinel执行下方命令，查看每个sentinel的信息</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -p sentinel端口</span><br><span class="line">info sentinel</span><br></pre></td></tr></table></figure>

<p>sentinel1信息如下：</p>
<img src="image-20230820074137891.png" alt="image-20230820074137891"/>

</li>
<li><p>验证故障自动转移是否成功</p>
<p>在master中执行下面命令，停止master</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -p 6379</span><br><span class="line">shutdown</span><br></pre></td></tr></table></figure>

<p>等待2分钟，等待完成故障转移</p>
<p>sentinel中我们配置down-after-milliseconds的值是60秒，表示判断主机下线时间是60秒，所以我们等2分钟，让系统先自动完成故障转移。</p>
<p>查看slave1的主从信息，如下：</p>
<img src="image-20230820075238438.png" alt="image-20230820075238438"/>

<p>查看slave2的主从信息，如下：</p>
<p>slave2变成了master，且slave1变成了slave2的从库，完成了故障转移。</p>
<img src="image-20230820075719038.png" alt="image-20230820075719038"/>

<p>验证下slave1和slave2是否同步</p>
<p>在slave2中执行下面命令</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; <span class="built_in">set</span> address china</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>在slave1中执行下面命令，查询address的值，效果如下，说明slave2和slave1同步正常</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; get address</span><br><span class="line"><span class="string">&quot;china&quot;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>恢复旧的master自动俯首称臣</p>
<p>当旧的master恢复之后，会自动挂在新的master下面。</p>
<p>执行下面命令，启动旧的master</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-server /home/llc/sentinel/redis-6379.conf</span><br></pre></td></tr></table></figure>

<p>执行下面命令，连接旧的master</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -p 6379</span><br></pre></td></tr></table></figure>

<p>执行下面命令，查看其主从信息</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="image-20230820080559580.png" alt="image-20230820080559580"/></li>
</ol>
<h4 id="SpringBoot整合Sentinel模式"><a href="#SpringBoot整合Sentinel模式" class="headerlink" title="SpringBoot整合Sentinel模式"></a>SpringBoot整合Sentinel模式</h4><ol>
<li><p>新建springboot项目，导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建配置文件application.yaml并配置redis sentinel相关信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="comment"># redis sentinel主服务名称，来源于：sentinel配置文件中sentinel monitor后面跟的那个名称</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span></span><br><span class="line">      <span class="comment"># sentinel节点列表（host:port），多个节点之间用逗号隔开</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">47.115</span><span class="number">.202</span><span class="number">.83</span><span class="string">:26379,</span> <span class="number">47.115</span><span class="number">.202</span><span class="number">.83</span><span class="string">:26380,</span> <span class="number">47.115</span><span class="number">.202</span><span class="number">.83</span><span class="string">:26381</span></span><br><span class="line">      <span class="comment"># sentinel密码</span></span><br><span class="line">      <span class="comment"># password: 123456</span></span><br><span class="line">    <span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">60000</span></span><br><span class="line">    <span class="comment"># Redis默认情况下有16个分片，这里配置具体使用的分片，默认为0</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写RedisController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/stringTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">StringTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zs&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">listTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;courses&quot;</span>);</span><br><span class="line">        redisTemplate.opsForList().rightPushAll(<span class="string">&quot;courses&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;c++&quot;</span>, <span class="string">&quot;python&quot;</span>);</span><br><span class="line">        List&lt;String&gt; courses = redisTemplate.opsForList().range(<span class="string">&quot;courses&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> courses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/setTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">setTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        redisTemplate.opsForSet().add(<span class="string">&quot;users&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; users = redisTemplate.opsForSet().members(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hashTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hashTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        Map&lt;String , String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;001&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zs&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().putAll(<span class="string">&quot;user&quot;</span>, map);</span><br><span class="line">        Map&lt;Object, Object&gt; user = redisTemplate.opsForHash().entries(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/zsetTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">zsetTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;languages&quot;</span>);</span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;languages&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;languages&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;languages&quot;</span>, <span class="string">&quot;python&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        Set&lt;String&gt; languages = redisTemplate.opsForZSet().range(<span class="string">&quot;languages&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> languages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看redis机器信息</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">RedisCallback</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.execute(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> obj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：安全组开放26379、26380、26381端口，且防火墙需要允许这些端口通过。</p>
<p>修改redis-xxx.conf的配置<code>bind 127.0.0.1</code>为<code>bind 0.0.0.0</code>。</p>
<p>修改sentinel-xxx.conf的配置<code>sentinel monitor mymaster 127.0.0.1 6379 2</code>为<code>sentinel monitor mymaster 47.115.202.83 6379 2</code>，即master节点的真实地址。</p>
</blockquote>
</li>
</ol>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><strong>存在问题</strong></p>
<ul>
<li>单台redis容量限制，如何进行扩容？继续加内存、加硬件么？</li>
<li>单台redis并发写量太大有性能瓶颈，如何解决？</li>
</ul>
<p>redis3.0中提供了集群可以解决这些问题。</p>
<p><strong>什么是集群？</strong></p>
<p>redis集群是对redis的水平扩容，即启动N个redis节点，将整个数据分布存储在这个N个节点中，每个节点存储总数据的1&#x2F;N。</p>
<p>如下图，由3台master和3台slave组成的redis集群，每台master承接客户端三分之一请求和写入的数据，当master挂掉后，slave会自动替代master，做到高可用。</p>
<img src="image-20230820103148537.png" alt="image-20230820103148537" style="zoom:80%;" />



<h4 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h4><p>下面我们来配置一个3主3从的集群，每个master下面挂一个slave，master挂掉后，slave会被提升为master。</p>
<p>为了方便，我们在一台机器上进行模拟，通过端口来区分6个不同的节点，配置信息如下：</p>
<img src="image-20230820103313938.png" alt="image-20230820103313938" style="zoom:80%;" />

<ol>
<li><p>创建案例工作目录：cluster</p>
<p>执行下面命令创建&#x2F;home&#x2F;llc&#x2F;cluster目录，本次所有操作，均在cluster目录下进行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /home/llc/cluster</span><br><span class="line"><span class="built_in">cd</span> /home/llc/cluster</span><br></pre></td></tr></table></figure>
</li>
<li><p>将redis.conf复制到cluster目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /home/llc/redis-6.0.8/redis.conf /home/llc/cluster/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建master1的配置文件：redis-6379.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis.conf是redis原配置文件，内部包含了很多默认的配置，这里使用include将其引用，相当于把redis.conf内容直接贴进来了</span><br><span class="line">include /home/llc/cluster/redis.conf</span><br><span class="line">daemonize yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">dir /home/llc/cluster/</span><br><span class="line">logfile /home/llc/cluster/6379.log</span><br><span class="line"></span><br><span class="line"># 端口</span><br><span class="line">port 6379</span><br><span class="line"># rdb文件</span><br><span class="line">dbfilename dump_6379.rdb</span><br><span class="line"># pid文件</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"># 开启集群设置</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 设置节点配置文件</span><br><span class="line">cluster-config-file node-6379.conf</span><br><span class="line"># 设置节点失联时间，超过该时间（毫秒），集群自动进行主从切换</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建master2的配置文件：redis-6380.conf（配置同redis-6379，修改对应端口号为6380）</p>
</li>
<li><p>创建master3的配置文件：redis-6381.conf（配置同redis-6379，修改对应端口号为6381）</p>
</li>
<li><p>创建slave1的配置文件：redis-6389.conf（配置同redis-6379，修改对应端口号为6389）</p>
</li>
<li><p>创建slave2的配置文件：redis-6390.conf（配置同redis-6379，修改对应端口号为6390）</p>
</li>
<li><p>创建slave3的配置文件：redis-6391.conf（配置同redis-6379，修改对应端口号为6391）</p>
</li>
<li><p>启动master、slave</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/llc/redis-6.0.8/src/</span><br><span class="line">./redis-server /home/llc/cluster/redis-6379.conf</span><br><span class="line">./redis-server /home/llc/cluster/redis-6380.conf</span><br><span class="line">./redis-server /home/llc/cluster/redis-6381.conf</span><br><span class="line">./redis-server /home/llc/cluster/redis-6389.conf</span><br><span class="line">./redis-server /home/llc/cluster/redis-6390.conf</span><br><span class="line">./redis-server /home/llc/cluster/redis-6391.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看6个redis的启动情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<img src="image-20230820224506695.png" alt="image-20230820224506695"/>
</li>
<li><p>确保node-xxx.conf文件已正常生成</p>
<p>稍后我们会将6个实例合并到一个集群，在组合之前，我们要确保6个redis实例启动后node-xxx.conf文件都正常生成，如下：</p>
<img src="image-20230820224601747.png" alt="image-20230820224601747"/>
</li>
<li><p>将6个节点合成一个集群</p>
<p>执行下方命令，将6个redis合体</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/llc/redis-6.0.8/src</span><br><span class="line">./redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6389 127.0.0.1:6390 127.0.0.1:6391</span><br></pre></td></tr></table></figure>

<blockquote>
<p>合体的命令后面跟上所有节点的ip:port列表，多个节点之间用空格隔开。</p>
<p>–cluster-replicas 1：表示采用最简单的方式配置集群，即每个master配1个slave，6个节点就形成了3主3从。</p>
<p>我们虽然指定了每个主节点都有一个从节点，但哪个是6379的从节点，却是随机分配的，直到集群创建完毕，才能确定是6389、6390还是6391。</p>
</blockquote>
<p>执行过程如下，期间会让我们确定是否同样这样的分配方式，输入：yes，然后等几秒，集群合体成功</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZf8zde65mian5izoh0918Z src]<span class="comment"># ./redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6389 127.0.0.1:6390 127.0.0.1:6391</span></span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 127.0.0.1:6390 to 127.0.0.1:6379</span><br><span class="line">Adding replica 127.0.0.1:6391 to 127.0.0.1:6380</span><br><span class="line">Adding replica 127.0.0.1:6389 to 127.0.0.1:6381</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span><br><span class="line">[WARNING] Some slaves are <span class="keyword">in</span> the same host as their master</span><br><span class="line">M: d70baeb81a52751234169cc130ea5d11644ac6d7 127.0.0.1:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 5ac6a0c8ef72177c0849e60b78389fad91ca8e39 127.0.0.1:6380</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 88775aff8e631f72289ce5739010feb41bb756b9 127.0.0.1:6381</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: b43507e89a56613e45d821f804730fddb588588f 127.0.0.1:6389</span><br><span class="line">   replicates d70baeb81a52751234169cc130ea5d11644ac6d7</span><br><span class="line">S: 1f6136fa929cfcf97812d897688054f7fd5cb94b 127.0.0.1:6390</span><br><span class="line">   replicates 5ac6a0c8ef72177c0849e60b78389fad91ca8e39</span><br><span class="line">S: 2bc0c7908016b61e97083bd4782c32e845a8449b 127.0.0.1:6391</span><br><span class="line">   replicates 88775aff8e631f72289ce5739010feb41bb756b9</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">&#x27;yes&#x27;</span> to accept): <span class="built_in">yes</span></span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to <span class="built_in">join</span></span><br><span class="line">.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:6379)</span><br><span class="line">M: d70baeb81a52751234169cc130ea5d11644ac6d7 127.0.0.1:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 5ac6a0c8ef72177c0849e60b78389fad91ca8e39 127.0.0.1:6380</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: b43507e89a56613e45d821f804730fddb588588f 127.0.0.1:6389</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates d70baeb81a52751234169cc130ea5d11644ac6d7</span><br><span class="line">S: 1f6136fa929cfcf97812d897688054f7fd5cb94b 127.0.0.1:6390</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5ac6a0c8ef72177c0849e60b78389fad91ca8e39</span><br><span class="line">S: 2bc0c7908016b61e97083bd4782c32e845a8449b 127.0.0.1:6391</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 88775aff8e631f72289ce5739010feb41bb756b9</span><br><span class="line">M: 88775aff8e631f72289ce5739010feb41bb756b9 127.0.0.1:6381</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

</li>
<li><p>连接集群节点，查看集群信息</p>
<p>使用redis-cli -c命令连接集群中6个节点中任何一个节点都可以，注意和之前的连接参数有点不同redis-cli命令后面多了一个<code>-c</code>参数，表示采用集群的方式连接。</p>
<p>连上以后，执行<code>cluster nodes</code>命令查看集群节点信息。</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZf8zde65mian5izoh0918Z src]<span class="comment"># ./redis-cli -c -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">5ac6a0c8ef72177c0849e60b78389fad91ca8e39 127.0.0.1:6380@16380 master - 0 1692543023000 2 connected 5461-10922</span><br><span class="line">b43507e89a56613e45d821f804730fddb588588f 127.0.0.1:6389@16389 slave d70baeb81a52751234169cc130ea5d11644ac6d7 0 1692543024643 1 connected</span><br><span class="line">1f6136fa929cfcf97812d897688054f7fd5cb94b 127.0.0.1:6390@16390 slave 5ac6a0c8ef72177c0849e60b78389fad91ca8e39 0 1692543022000 2 connected</span><br><span class="line">d70baeb81a52751234169cc130ea5d11644ac6d7 127.0.0.1:6379@16379 myself,master - 0 1692543020000 1 connected 0-5460</span><br><span class="line">2bc0c7908016b61e97083bd4782c32e845a8449b 127.0.0.1:6391@16391 slave 88775aff8e631f72289ce5739010feb41bb756b9 0 1692543022615 3 connected</span><br><span class="line">88775aff8e631f72289ce5739010feb41bb756b9 127.0.0.1:6381@16381 master - 0 1692543023640 3 connected 10923-16383</span><br></pre></td></tr></table></figure>

<p>如下图，对cluster nodes命令的结果进行解释，集群中的每个节点都会生成一个ID，这个ID信息会被写入到node-xxx.conf文件中，为什么要生成id呢？因为节点的ip和端口可能会发生变化，但是节点的ID是不会变的，其他节点可以通过节点的ID来认识该节点。</p>
<img src="image-20230820225730306.png" alt="image-20230820225730306"/>
</li>
<li><p>验证集群数据的读写操作</p>
<p>连接6379这个节点，执行一个set操作，效果如下，写入成功</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZf8zde65mian5izoh0918Z src]<span class="comment"># ./redis-cli -c -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name zs</span><br><span class="line">-&gt; Redirected to slot [5798] located at 127.0.0.1:6380</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt;</span><br></pre></td></tr></table></figure>

<p>此时我们在6379上进行操作，但是请求被转发到6380这个节点进行处理，这里就是我们后面要说的slot的知识。</p>
<blockquote>
<ul>
<li><p>redis集群如何分配这6个节点？</p>
<p>一个集群至少有3个主节点，因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的。</p>
</li>
<li><p>分配原则尽量保证每个主库运行在不同的ip，每个主库和从库不在一个ip上，这样才能做到高可用。</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="slot（槽）"><a href="#slot（槽）" class="headerlink" title="slot（槽）"></a>slot（槽）</h4><p><strong>什么是slot？</strong></p>
<p>如下图，咱们再来看看集群合并过程中输出的一些信息</p>
<img src="image-20230820224942167.png" alt="image-20230820224942167"/>

<p>Redis集群内部划分了16384个slots（插槽），合并的时候会将每个slots映射到一个master上面，比如上面3个master和slots的关系如下：</p>
<table>
<thead>
<tr>
<th>redis主节点</th>
<th>槽位范围</th>
</tr>
</thead>
<tbody><tr>
<td>master1（端口：6379）</td>
<td>[0-5460]，插槽的位置从0开始，0表示第1个插槽</td>
</tr>
<tr>
<td>master2（端口：6380）</td>
<td>[5461-10922]</td>
</tr>
<tr>
<td>master3（端口：6381）</td>
<td>[10923-16383]</td>
</tr>
<tr>
<td>slave1、slave2、slave3</td>
<td>从节点没有槽位，slave是用来对master做替补的</td>
</tr>
</tbody></table>
<p>数据库中的每个key都属于16384个slots中的其中1个，当通过key读写数据的时候，redis需要先根据key计算出key对应的slots，然后根据slots和master的映射关系找到对应的redis节点，key对应的数据就在这个节点上面。</p>
<p>集群中使用公式<code>CRC16(key) % 16384</code>计算key属于哪个槽。</p>
<p><strong>在集群中录入值</strong></p>
<p>redis-cli每次录入、查询键值，redis都会计算key对应的插槽，如果不是当前redis节点的插槽，redis会报错，并告知应前往的redis实例地址和端口，效果如下，我们连接了6379这个实例来操作k1，这个节点发现k1的槽位在6381上面，返回了错误信息，怎么办呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZf8zde65mian5izoh0918Z src]<span class="comment"># ./redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">(error) MOVED 12706 127.0.0.1:6381</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p>使用redis-cli客户端提供的<code>-c</code>参数可以解决这个问题，表示以集群方式执行，执行命令的时候当前节点处理不了的时候，会自动将请求重定向到目标节点，效果如下，被重定向到了6381。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZf8zde65mian5izoh0918Z src]<span class="comment"># ./redis-cli -c -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">-&gt; Redirected to slot [12706] located at 127.0.0.1:6381</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6381&gt;</span><br></pre></td></tr></table></figure>

<p>同样，执行get会被重定向，效果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZf8zde65mian5izoh0918Z src]<span class="comment"># ./redis-cli -c -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">-&gt; Redirected to slot [12706] located at 127.0.0.1:6381</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6381&gt;</span><br></pre></td></tr></table></figure>

<p>不在一个slot下面，不能使用mget、mset等多键操作，效果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; mset k1 v1 k2 v2</span><br><span class="line">(error) CROSSSLOT Keys <span class="keyword">in</span> request don<span class="string">&#x27;t hash to the same slot</span></span><br><span class="line"><span class="string">127.0.0.1:6381&gt; mget k1 k2</span></span><br><span class="line"><span class="string">(error) CROSSSLOT Keys in request don&#x27;</span>t <span class="built_in">hash</span> to the same slot</span><br></pre></td></tr></table></figure>

<p>可以通过{}来定义组的概念，从而使key中{}内相同的键值放到一个slot中去，效果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; mset k1&#123;g1&#125; v1 k2&#123;g1&#125; v2 k3&#123;g1&#125; v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6381&gt; mget k1&#123;g1&#125; k2&#123;g1&#125; k3&#123;g1&#125;</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>k1{g1}：相对于将键k1放入g1对应的slot中</p>
</blockquote>
<p><strong>slot相关的一些命令</strong></p>
<ul>
<li>cluster keyslot key：计算key对应的slot</li>
<li>cluster countkeysinslot slot：获取slot槽位中key的个数</li>
<li>cluster getkeysinslot slot count：从slot槽位中取出count个key</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; cluster keyslot k1&#123;g1&#125;</span><br><span class="line">(<span class="built_in">integer</span>) 13519</span><br><span class="line">127.0.0.1:6381&gt; cluster countkeysinslot 13519</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6381&gt; cluster getkeysinslot 13519 3</span><br><span class="line">1) <span class="string">&quot;k1&#123;g1&#125;&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&#123;g1&#125;&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&#123;g1&#125;&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p>如果主节点下线，从节点是否能够提升为主节点？注意：<code>需要等15秒</code></p>
<p>下面我们来试试，如下，连接master1，然后将master1停掉：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -c -p 6379</span><br><span class="line">shutdown</span><br></pre></td></tr></table></figure>

<p>执行下面命令，连接master2，查看集群节点信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -c -p 6380</span><br><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>

<p>输出如下，可以看到slave1（6389）确实变成master了，而它原来的master：master1（6379）下线了。</p>
<img src="image-20230820230303604.png" alt="image-20230820230303604"/>

<p>重新启动6379，然后再看看集群变成什么样了，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-server /home/llc/cluster/redis-6379.conf</span><br><span class="line">./redis-cli -c -p 6379</span><br><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>

<p>执行结果如下，6379变成了slave，挂在了6389的下面。</p>
<img src="image-20230820230912019.png" alt="image-20230820230912019"/>

<blockquote>
<p>如果某一段插槽的主从都宕机了，redis服务是否还能继续？</p>
<p>这个时候就要看<code>cluster-require-full-coverage</code>参数的值了，参数值如下：</p>
<ul>
<li>yes（默认值）：整个集群都无法提供服务；</li>
<li>no：宕机的这部分槽位数据全部不能使用，其他槽位正常。</li>
</ul>
</blockquote>
<h4 id="SpringBoot整合redis集群"><a href="#SpringBoot整合redis集群" class="headerlink" title="SpringBoot整合redis集群"></a>SpringBoot整合redis集群</h4><ol>
<li><p>新建springboot项目，导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建配置文件aplication.yaml并配置redis cluster的信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="comment"># 集群节点（host:port），多个节点之间用逗号隔开</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">47.115</span><span class="number">.202</span><span class="number">.83</span><span class="string">:6379,</span> <span class="number">47.115</span><span class="number">.202</span><span class="number">.83</span><span class="string">:6380,</span> <span class="number">47.115</span><span class="number">.202</span><span class="number">.83</span><span class="string">:6381,</span> <span class="number">47.115</span><span class="number">.202</span><span class="number">.83</span><span class="string">:6389,</span> <span class="number">47.115</span><span class="number">.202</span><span class="number">.83</span><span class="string">:6390,</span> <span class="number">47.115</span><span class="number">.202</span><span class="number">.83</span><span class="string">:6391</span></span><br><span class="line">    <span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">60000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写RedisController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/stringTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">StringTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zs&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">listTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;courses&quot;</span>);</span><br><span class="line">        redisTemplate.opsForList().rightPushAll(<span class="string">&quot;courses&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;c++&quot;</span>, <span class="string">&quot;python&quot;</span>);</span><br><span class="line">        List&lt;String&gt; courses = redisTemplate.opsForList().range(<span class="string">&quot;courses&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> courses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/setTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">setTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        redisTemplate.opsForSet().add(<span class="string">&quot;users&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; users = redisTemplate.opsForSet().members(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hashTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hashTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        Map&lt;String , String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;001&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zs&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().putAll(<span class="string">&quot;user&quot;</span>, map);</span><br><span class="line">        Map&lt;Object, Object&gt; user = redisTemplate.opsForHash().entries(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/zsetTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">zsetTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;languages&quot;</span>);</span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;languages&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;languages&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;languages&quot;</span>, <span class="string">&quot;python&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        Set&lt;String&gt; languages = redisTemplate.opsForZSet().range(<span class="string">&quot;languages&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> languages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看redis机器信息</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">RedisCallback</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.execute(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> obj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：安全组开放6379、6380、6381、6389、6390、6391端口，且防火墙需要允许这些端口通过。</p>
<p>修改redis-xxx.conf的配置<code>bind 127.0.0.1</code>为<code>bind 0.0.0.0</code></p>
<p>在将6个节点合成一个集群时，对应节点ip需要为真实ip，即</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli --cluster create --cluster-replicas 1 47.115.202.83:6379 47.115.202.83:6380 47.115.202.83:6381 47.115.202.83:6389 47.115.202.83:6390 47.115.202.83:6391</span><br></pre></td></tr></table></figure>

<p>可能会遇到的问题：<code>Waiting for the cluster to join</code>一直等待。</p>
<p>原因：redis集群不仅需要开通redis客户端连接的端口，而且需要开通集群总线端口。集群总线端口为redis客户端连接的端口 + 10000，如redis端口为6379，则集群总线端口为16379。</p>
<p>解决方法：安全组开放16379、16380、16381、16389、16390、16391端口，且防火墙需要允许这些端口通过。</p>
</blockquote>
</li>
</ol>
<h2 id="Redis应用问题解决"><a href="#Redis应用问题解决" class="headerlink" title="Redis应用问题解决"></a>Redis应用问题解决</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>问题描述</strong></p>
<p>当系统中引入redis缓存后，一个请求进来后，会先在redis缓存中查询，缓存有就直接返回，缓存中没有就去db中查询，db中如果有就会将其丢到缓存中。但是有些key对应数据在db中并不存在，每次针对这个key的请求从缓存中取不到，请求都会压到db，从而可能压垮db。</p>
<p>比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用大量此类攻击可能压垮数据库。</p>
<p><strong>解决方案</strong></p>
<ol>
<li><p>对空值缓存</p>
<p>如果一个查询返回的数据为空（不管数据库是否存在），我们仍然把这个结果（null）进行缓存，给其设置一个很短的过期时间，最长不超过五分钟。</p>
<blockquote>
<p>例如：当某个用户id在缓存中查不到，在数据库中也查不到时，也需要将该用户id缓存起来，只不过值是空的。这样后面的请求，再拿相同的用户id发起请求时，就能从缓存中获取空数据，直接返回了，而无需再去查一次数据库。</p>
</blockquote>
</li>
<li><p>设置可访问的名单（白名单）</p>
<p>使用redis中的bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次范文和bitmap里面的id进行比较，如果访问的id不在bitmaps里面，则进行拦截，不允许访问。</p>
</li>
<li><p>采用布隆过滤器</p>
<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的，它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p>
<p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p>
</li>
<li><p>进行实时监控</p>
<p>当发现redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制对其提供服务（比如：IP黑名单）</p>
</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>问题描述</strong></p>
<p>redis中某个热点key（访问量很高的key）过期，此时大量请求同时过来，发现缓存中没有命中，这些请求都打到db上了，导致db压力瞬时大增，可能会打垮db，这种情况称为缓存击穿。</p>
<p>缓存击穿出现的现象：</p>
<ul>
<li>数据库访问压力瞬时增大</li>
<li>redis里面没有出现大量的key过期</li>
<li>redis正常运行</li>
</ul>
<p><strong>解决方案</strong></p>
<p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据，这个时候，要考虑一个问题：缓存被“击穿”的问题，常见的解决方案如下：</p>
<ol>
<li><p>预先设置热门数据，适时调整过期时间</p>
<p>在redis高峰之前，把一些热门数据提前存入到redis里面，对缓存中的这些热门数据进行监控，实时调整过期时间。</p>
</li>
<li><p>使用锁</p>
<p>缓存中拿不到数据的时候，此时不是立即去db中查询，而是去获取分布式锁（比如redis中的setnx），拿到锁再去db中load数据；没有拿到锁的线程休眠一段时间再重试整个获取数据的方法。</p>
</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>问题描述</strong></p>
<p>key对应的数据存在，但是极短时间内有大量的key集中过期，此时若有大量的并发请求过来，发现缓存没有数据，大量的请求就会落到db上去加载数据，会将db击垮，导致服务奔溃。</p>
<p>缓存雪崩与缓存击穿的区别在于：前者是大量的key集中过期，而后者是某个热点key过期。</p>
<p><strong>解决方案</strong></p>
<p>缓存失效时的雪崩效益对底层系统的冲击非常可怕，常见的解决方案如下：</p>
<ol>
<li><p>构建多级缓存</p>
<p>nginx缓存 + redis缓存 + 其他缓存（ehcache等）</p>
</li>
<li><p>使用锁或队列</p>
<p>用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，不适用高并发情况。</p>
</li>
<li><p>监控缓存过期，提前更新</p>
<p>监控缓存，发下缓存快过期了，提前对缓存进行更新。</p>
</li>
<li><p>将缓存失效时间分散开</p>
<p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样缓存的过期时间重复率就会降低，就很难引发集体失效的事件。</p>
</li>
</ol>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><strong>问题描述</strong></p>
<p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。</p>
<p><strong>分布式锁主流的实现方案</strong></p>
<ol>
<li>基于数据库实现分布式锁</li>
<li>基于缓存（redis等）</li>
<li>基于zookeeper</li>
</ol>
<p>每一种分布式锁解决方案都有各自的优缺点</p>
<ul>
<li>性能：redis最高</li>
<li>可靠性：zookeeper最高</li>
</ul>
<p>这里我们基于redis实现分布式锁。</p>
<p><strong>使用redis实现分布式锁</strong></p>
<p>需要使用下面这个命令来实现分布式锁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value NX PX 有效期（毫秒）</span><br></pre></td></tr></table></figure>

<p>这条命令表示：当key不存在的时候，设置其值为value，且同时设置其有效期。</p>
<p>示例：表示当sku:1:info不存在的时候，设置值为ok，且有效期为1万毫秒。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> sku:1:info <span class="string">&quot;ok&quot;</span> NX PX 10000</span><br></pre></td></tr></table></figure>

<p>上锁过程如下图，执行<code>set key value NX PX 有效期（毫秒）</code>命令，返回ok表示执行成功，则获取锁成功。多个客户端并发执行此命令的时候，redis可以确保只有一个执行成功。</p>
<img src="image-20230821111912368.png" alt="image-20230821111912368" style="zoom:80%;" />

<blockquote>
<ul>
<li><p>为什么要设置过期时间？</p>
<p>客户端获取锁后，由于系统问题，如系统宕机了，会导致锁无法释放，其他客户端就无法获取锁了，所以需要给锁指定一个使用期限。</p>
</li>
<li><p>如果设置的有效期太短怎么办？</p>
<p>比如有效期设置了10秒，但是10秒不够业务方使用，这种情况客户端需要实现续命的功能，可以解决这个问题。</p>
</li>
<li><p>解决锁误删的问题</p>
<p>锁存在误删的情况：所谓误删就是自己把别人持有的锁给删掉了。</p>
<p>比如线程A获取锁的时候，设置的有效期是10秒，但是执行业务的时候A程序突然卡住了，超过了10秒，此时这个锁就可能被其他线程拿到，比如被线程B拿到了，然后A从卡顿中恢复了，继续执行业务，业务执行完毕之后，去执行了释放锁的操作，此时A会执行del命令，此时就出现了锁的误删，导致的结果就是把B持有的锁给释放了，然后其他线程又会获取这个锁。</p>
<p>如何解决呢？</p>
<p>获取锁之前，生成一个全局唯一id，将这个id也丢到key对应的value中，释放锁之前，从redis中将这个id拿出来和本地的比较一下，看看是不是自己的id，如果是再执行del释放锁的操作。</p>
</li>
<li><p>还是存在误删的可能（原子操作问题）</p>
<p>上面说到del之前，会先从redis中读取id，然后和本地id对比一下，如果一致，则执行删除，伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step1: 判断 redis.get(&quot;key&quot;).id == 本地id 是否相等,如果是则执行step2</span><br><span class="line">step2: del key;</span><br></pre></td></tr></table></figure>

<p>此时如果执行step2的时候系统卡住了，比如卡住了10秒，然后redis才收到，这个期间锁可能又被其他线程获取了，此时又发生了误删的操作。</p>
<p>这个问题的根本原因是：判断和删除这2个步骤对redis来说不是原子操作。</p>
<p>怎么解决呢？需要使用Lua脚本来解决。</p>
</li>
<li><p>终极方案：使用Lua脚本来释放锁</p>
<p>将复杂或者多步的redis操作写为一个脚本，一次提交给redis执行，减少反复连接redis的次数，提升性能。</p>
<p>Lua脚本类似于redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务的操作。</p>
<p>注意：redis的Lua脚本功能，只能在redis2.6以上版本才能使用。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/lock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockkey</span> <span class="operator">=</span> <span class="string">&quot;k1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 1. 获取锁，有效期10秒</span></span><br><span class="line">        <span class="keyword">if</span>(redisTemplate.opsForValue().setIfAbsent(lockkey, uuid, <span class="number">10</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">            <span class="comment">// 2. 执行业务</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 使用Lua脚本释放锁（可防止误删）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">            DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">            redisScript.setScriptText(script);</span><br><span class="line">            redisScript.setResultType(Long.class);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(redisScript, Arrays.asList(lockkey), uuid);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;获取锁成功！&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;加锁失败！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分布式锁总结</p>
<p>为了确保分布式锁可用，我们至少需要确保分布式锁的实现同时满足以下四个条件：</p>
<ul>
<li>互斥性：在任意时刻只能有一个客户端能够持有锁。</li>
<li>不会发生死锁：即使有一个客户端在持有锁期间崩溃而没有释放锁，也能够保证后续其他客户端能够加锁。</li>
<li>解锁还需寄铃人：加锁和解锁必须是同一个客户端，客户端不能把别人的锁给解了。</li>
<li>加锁和解锁必须有原子性。</li>
</ul>
</li>
</ul>
</blockquote>
</article><div class="tag_share"><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小辑轻舟</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuliangcong"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">Windows安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.</span> <span class="toc-text">Linux安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">Redis配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%EF%BC%88Key%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">键（Key）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">字符串（String）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">列表（List）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">集合（Set）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%EF%BC%88Hash%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">哈希（Hash）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88Zset%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">有序集合（Zset）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%96%B0%E7%9A%843%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">Redis新的3种数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmaps%EF%BC%9A%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.1.</span> <span class="toc-text">Bitmaps：位操作字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLoglog"><span class="toc-number">5.2.</span> <span class="toc-text">HyperLoglog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geographic"><span class="toc-number">5.3.</span> <span class="toc-text">Geographic</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">6.</span> <span class="toc-text">发布订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jedis%E6%93%8D%E4%BD%9CRedis"><span class="toc-number">7.</span> <span class="toc-text">Jedis操作Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E6%95%B4%E5%90%88Redis"><span class="toc-number">8.</span> <span class="toc-text">SpringBoot整合Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">9.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.1.</span> <span class="toc-text">事务介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">9.2.</span> <span class="toc-text">相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">9.3.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%86%B2%E7%AA%81"><span class="toc-number">9.4.</span> <span class="toc-text">事务冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">9.4.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">9.4.2.</span> <span class="toc-text">乐观锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB"><span class="toc-number">10.1.</span> <span class="toc-text">RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF"><span class="toc-number">10.2.</span> <span class="toc-text">AOF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">11.2.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">11.3.</span> <span class="toc-text">主从复制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84"><span class="toc-number">11.4.</span> <span class="toc-text">常用的主从结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-number">11.4.1.</span> <span class="toc-text">一主二从</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-number">11.4.2.</span> <span class="toc-text">薪火相传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-number">11.4.3.</span> <span class="toc-text">反客为主</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%EF%BC%88Sentinel%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.5.</span> <span class="toc-text">哨兵（Sentinel）模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">11.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">11.5.2.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E6%95%B4%E5%90%88Sentinel%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.5.3.</span> <span class="toc-text">SpringBoot整合Sentinel模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4"><span class="toc-number">12.</span> <span class="toc-text">Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">12.0.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">12.0.2.</span> <span class="toc-text">集群配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slot%EF%BC%88%E6%A7%BD%EF%BC%89"><span class="toc-number">12.0.3.</span> <span class="toc-text">slot（槽）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">12.0.4.</span> <span class="toc-text">故障恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E6%95%B4%E5%90%88redis%E9%9B%86%E7%BE%A4"><span class="toc-number">12.0.5.</span> <span class="toc-text">SpringBoot整合redis集群</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">13.</span> <span class="toc-text">Redis应用问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">13.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">13.2.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">13.3.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">13.4.</span> <span class="toc-text">分布式锁</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/06/Nginx/" title="Nginx">Nginx</a><time datetime="2024-02-06T12:51:43.000Z" title="发表于 2024-02-06 20:51:43">2024-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/28/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/" title="网页布局方式">网页布局方式</a><time datetime="2024-01-28T10:35:05.000Z" title="发表于 2024-01-28 18:35:05">2024-01-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/28/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/" title="CSS预处理器">CSS预处理器</a><time datetime="2024-01-28T10:09:08.000Z" title="发表于 2024-01-28 18:09:08">2024-01-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/28/Redis/" title="Redis">Redis</a><time datetime="2024-01-28T09:40:41.000Z" title="发表于 2024-01-28 17:40:41">2024-01-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/18/Git/" title="Git">Git</a><time datetime="2023-09-18T03:54:31.000Z" title="发表于 2023-09-18 11:54:31">2023-09-18</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgb(116,116,116)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 小辑轻舟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p style="letter-spacing:2px; margin-top:0">平明拂剑朝天去，薄暮垂鞭醉酒归！<p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>